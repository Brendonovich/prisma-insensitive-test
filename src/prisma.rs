// Code generated by Prisma Client Rust. DO NOT EDIT

#![allow(warnings, unused)]
use prisma_client_rust::{
    bigdecimal::{self, FromPrimitive},
    chrono,
    datamodel::parse_configuration,
    operator::Operator,
    prisma_models::{InternalDataModelBuilder, PrismaValue},
    queries::{QueryContext, QueryInfo, Result as QueryResult},
    query_core::{
        executor, schema_builder, CoreError, InterpreterError, QueryExecutor,
        QueryGraphBuilderError, QueryValue, Selection,
    },
    schema::QuerySchema,
    serde_json, BatchResult, Direction, ManyArgs, SerializedWhere, SerializedWhereValue,
    UniqueArgs,
};
use serde::{Deserialize, Serialize};
use std::path::Path;
use std::sync::Arc;
static DATAMODEL_STR : & 'static str = "generator client {\n  // Corresponds to the cargo alias created earlier\n  provider = \"cargo prisma\"\n  // The location to generate the schema. Is relative to the position of the schema\n  output   = \"../src/prisma.rs\"\n}\n\ndatasource db {\n  provider = \"postgresql\"\n  url      = env(\"DATABASE_URL\")\n}\n\nmodel Activity {\n  ID             String           @id\n  UpdatedAt      DateTime         @default(now())\n  CreatedAt      DateTime         @default(now())\n  Name           String           @unique\n  UserId         String\n  User           User             @relation(fields: [UserId], references: [ID])\n  DeviceActivity DeviceActivity[]\n}\n\nmodel Device {\n  ID             String           @id\n  Name           String           @unique\n  DeviceActivity DeviceActivity[]\n}\n\nmodel DeviceActivity {\n  ID         String    @id\n  UpdatedAt  DateTime  @default(now())\n  CreatedAt  DateTime  @default(now())\n  ActivityId String?\n  DeviceId   String\n  Activity   Activity? @relation(fields: [ActivityId], references: [ID])\n  Device     Device    @relation(fields: [DeviceId], references: [ID])\n}\n\nmodel User {\n  ID       String     @id\n  Name     String     @unique\n  ApiKey   String     @unique\n  Activity Activity[]\n}\n" ;
static DATABASE_STR: &'static str = "postgresql";
pub async fn new_client() -> Result<_prisma::PrismaClient, ::prisma_client_rust::NewClientError> {
    let config = ::prisma_client_rust::datamodel::parse_configuration(DATAMODEL_STR)?.subject;
    let source = config
        .datasources
        .first()
        .expect("Please supply a datasource in your schema.prisma file");
    let url = if let Some(url) = source.load_shadow_database_url()? {
        url
    } else {
        source.load_url(|key| std::env::var(key).ok())?
    };
    let url = if url.starts_with("file:") {
        let path = url.split(":").nth(1).unwrap();
        if std::path::Path::new("./schema.prisma").exists() {
            url
        } else if std::path::Path::new("./prisma/schema.prisma").exists() {
            format!("file:./prisma/{}", path)
        } else {
            url
        }
    } else {
        url
    };
    new_client_with_url(&url).await
}
pub async fn new_client_with_url(
    url: &str,
) -> Result<_prisma::PrismaClient, ::prisma_client_rust::NewClientError> {
    let config = ::prisma_client_rust::datamodel::parse_configuration(DATAMODEL_STR)?.subject;
    let source = config
        .datasources
        .first()
        .expect("Please supply a datasource in your schema.prisma file");
    let (db_name, executor) =
        ::prisma_client_rust::query_core::executor::load(&source, &[], &url).await?;
    let internal_model =
        ::prisma_client_rust::prisma_models::InternalDataModelBuilder::new(DATAMODEL_STR)
            .build(db_name);
    let query_schema = std::sync::Arc::new(schema_builder::build(
        internal_model,
        true,
        source.capabilities(),
        vec![],
        source.referential_integrity(),
    ));
    executor.primary_connector().get_connection().await?;
    Ok(PrismaClient::_new(executor, query_schema))
}
pub mod activity {
    use super::_prisma::*;
    use super::*;
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn cursor(cursor: String) -> Cursor {
            Cursor::Id(cursor)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::IdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::IdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::IdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::IdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::IdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::IdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::IdEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::IdMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::IdNot(value)
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetId(value.0)
            }
        }
    }
    pub mod updated_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: chrono::DateTime<chrono::FixedOffset>) -> T {
            Set(value).into()
        }
        pub fn equals(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::UpdatedAt(direction)
        }
        pub fn in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::UpdatedAtInVec(value)
        }
        pub fn not_in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::UpdatedAtNotInVec(value)
        }
        pub fn lt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtLt(value)
        }
        pub fn lte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtLte(value)
        }
        pub fn gt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtGt(value)
        }
        pub fn gte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtGte(value)
        }
        pub fn not(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtNot(value)
        }
        pub struct Set(pub chrono::DateTime<chrono::FixedOffset>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetUpdatedAt(value.0)
            }
        }
    }
    pub mod created_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: chrono::DateTime<chrono::FixedOffset>) -> T {
            Set(value).into()
        }
        pub fn equals(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::CreatedAt(direction)
        }
        pub fn in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::CreatedAtInVec(value)
        }
        pub fn not_in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::CreatedAtNotInVec(value)
        }
        pub fn lt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtLt(value)
        }
        pub fn lte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtLte(value)
        }
        pub fn gt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtGt(value)
        }
        pub fn gte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtGte(value)
        }
        pub fn not(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtNot(value)
        }
        pub struct Set(pub chrono::DateTime<chrono::FixedOffset>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetCreatedAt(value.0)
            }
        }
    }
    pub mod name {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::NameEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Name(direction)
        }
        pub fn cursor(cursor: String) -> Cursor {
            Cursor::Name(cursor)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::NameInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::NameNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::NameLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::NameLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::NameGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::NameGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::NameContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::NameStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::NameEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::NameMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::NameNot(value)
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetName(value.0)
            }
        }
    }
    pub mod user_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::UserIdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::UserId(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::UserIdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::UserIdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::UserIdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::UserIdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::UserIdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::UserIdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::UserIdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::UserIdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::UserIdEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::UserIdMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::UserIdNot(value)
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetUserId(value.0)
            }
        }
    }
    pub mod user {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn is(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::UserIs(value)
        }
        pub fn is_not(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::UserIsNot(value)
        }
        pub struct Fetch(pub user::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<user::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::User(fetch.0)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(user::UniqueArgs::new())
        }
        pub fn link<T: From<Link>>(value: user::UniqueWhereParam) -> T {
            Link(value).into()
        }
        pub struct Link(user::UniqueWhereParam);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::ConnectUser(value.0)
            }
        }
    }
    pub mod device_activity {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn some(value: Vec<device_activity::WhereParam>) -> WhereParam {
            WhereParam::DeviceActivitySome(value)
        }
        pub fn every(value: Vec<device_activity::WhereParam>) -> WhereParam {
            WhereParam::DeviceActivityEvery(value)
        }
        pub fn none(value: Vec<device_activity::WhereParam>) -> WhereParam {
            WhereParam::DeviceActivityNone(value)
        }
        pub struct Fetch(pub device_activity::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<device_activity::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: impl Into<device_activity::OrderByParam>) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: impl Into<device_activity::Cursor>) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::DeviceActivity(fetch.0)
            }
        }
        pub fn fetch(params: Vec<device_activity::WhereParam>) -> Fetch {
            Fetch(device_activity::ManyArgs::new(params))
        }
        pub fn link<T: From<Link>>(params: Vec<device_activity::UniqueWhereParam>) -> T {
            Link(params).into()
        }
        pub fn unlink(params: Vec<device_activity::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectDeviceActivity(params)
        }
        pub fn set(params: Vec<device_activity::UniqueWhereParam>) -> SetParam {
            SetParam::SetDeviceActivity(params)
        }
        pub struct Link(pub Vec<device_activity::UniqueWhereParam>);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::ConnectDeviceActivity(value.0)
            }
        }
    }
    pub fn _outputs() -> Vec<::prisma_client_rust::Selection> {
        ["ID", "UpdatedAt", "CreatedAt", "Name", "UserId"]
            .into_iter()
            .map(|o| {
                let builder = ::prisma_client_rust::Selection::builder(o);
                builder.build()
            })
            .collect()
    }
    pub fn create(
        id: String,
        name: String,
        user: super::user::UniqueWhereParam,
        _params: Vec<SetParam>,
    ) -> (String, String, super::user::UniqueWhereParam, Vec<SetParam>) {
        (id, name, user, _params)
    }
    #[macro_export]
    macro_rules ! _select_activity { ($ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ ({ $ ($ selections : tt) + }) ?) +) => { { $ crate :: prisma :: activity :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ ({ $ ($ selections) + }) ?) +) ; Select ($ crate :: prisma :: activity :: select ! (@ select_fields_to_selections ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ ({ $ ($ selections) + }) ?) +)) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ ({ $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , updated_at , created_at , name , user_id , user , device_activity } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [derive (:: serde :: Deserialize , :: serde :: Serialize)] # [allow (warnings)] pub struct Data { $ ($ field : $ crate :: prisma :: activity :: select ! (@ field_type ; $ field $ ({ $ ($ selections) + }) ?) ,) + } $ ($ (pub mod $ field { $ crate :: prisma :: activity :: select ! (@ field_module ; $ field { $ ($ selections) + }) ; }) ?) + pub struct Select (pub Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType < $ crate :: prisma :: activity :: Data > for Select { type Data = Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } } ; (@ field_type ; id) => { String } ; (@ field_type ; updated_at) => { chrono :: DateTime < chrono :: FixedOffset > } ; (@ field_type ; created_at) => { chrono :: DateTime < chrono :: FixedOffset > } ; (@ field_type ; name) => { String } ; (@ field_type ; user_id) => { String } ; (@ field_type ; user { $ ($ selections : tt) + }) => { user :: Data } ; (@ field_type ; user) => { crate :: prisma :: user :: Data } ; (@ field_type ; device_activity { $ ($ selections : tt) + }) => { Vec < device_activity :: Data > } ; (@ field_type ; device_activity) => { Vec < crate :: prisma :: device_activity :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model activity)) } ; (@ field_module ; user { $ ($ selections : tt) + }) => { $ crate :: prisma :: user :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; device_activity { $ ($ selections : tt) + }) => { $ crate :: prisma :: device_activity :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ select_fields_to_selections ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ ({ $ ($ selections : tt) + }) ?) +) => { vec ! [$ ($ crate :: prisma :: activity :: select ! (@ select_field_to_selection ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ ({ $ ($ selections) + }) ?)) , +] } ; (@ select_field_to_selection ; id) => { :: prisma_client_rust :: Selection :: builder ("ID") . build () } ; (@ select_field_to_selection ; updated_at) => { :: prisma_client_rust :: Selection :: builder ("UpdatedAt") . build () } ; (@ select_field_to_selection ; created_at) => { :: prisma_client_rust :: Selection :: builder ("CreatedAt") . build () } ; (@ select_field_to_selection ; name) => { :: prisma_client_rust :: Selection :: builder ("Name") . build () } ; (@ select_field_to_selection ; user_id) => { :: prisma_client_rust :: Selection :: builder ("UserId") . build () } ; (@ select_field_to_selection ; user $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? { $ ($ selections : tt) + }) => { { # [allow (warnings)] let mut selection = :: prisma_client_rust :: Selection :: builder ("User") ; $ (let args = $ crate :: prisma :: user :: ManyArgs :: new ($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) * ; selection . set_arguments (args . to_graphql () . 0) ;) ? selection . nested_selections ($ crate :: prisma :: user :: select ! (@ select_fields_to_selections ; $ ($ selections) +)) ; selection . build () } } ; (@ select_field_to_selection ; user $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { # [allow (warnings)] let mut selection = :: prisma_client_rust :: Selection :: builder ("User") ; $ (let args = $ crate :: prisma :: user :: ManyArgs :: new ($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) * ; selection . set_arguments (args . to_graphql () . 0) ;) ? selection . nested_selections ($ crate :: prisma :: user :: _outputs ()) ; selection . build () } } ; (@ select_field_to_selection ; device_activity $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? { $ ($ selections : tt) + }) => { { # [allow (warnings)] let mut selection = :: prisma_client_rust :: Selection :: builder ("DeviceActivity") ; $ (let args = $ crate :: prisma :: device_activity :: ManyArgs :: new ($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) * ; selection . set_arguments (args . to_graphql () . 0) ;) ? selection . nested_selections ($ crate :: prisma :: device_activity :: select ! (@ select_fields_to_selections ; $ ($ selections) +)) ; selection . build () } } ; (@ select_field_to_selection ; device_activity $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { # [allow (warnings)] let mut selection = :: prisma_client_rust :: Selection :: builder ("DeviceActivity") ; $ (let args = $ crate :: prisma :: device_activity :: ManyArgs :: new ($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) * ; selection . set_arguments (args . to_graphql () . 0) ;) ? selection . nested_selections ($ crate :: prisma :: device_activity :: _outputs ()) ; selection . build () } } ; (@ select_field_to_selection ; $ ($ tokens : tt) *) => { :: prisma_client_rust :: Selection :: builder ("") . build () } ; }
    pub use _select_activity as select;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "ID")]
        pub id: String,
        #[serde(rename = "UpdatedAt")]
        pub updated_at: chrono::DateTime<chrono::FixedOffset>,
        #[serde(rename = "CreatedAt")]
        pub created_at: chrono::DateTime<chrono::FixedOffset>,
        #[serde(rename = "Name")]
        pub name: String,
        #[serde(rename = "UserId")]
        pub user_id: String,
        #[serde(rename = "User")]
        pub user: Option<Box<super::user::Data>>,
        #[serde(rename = "DeviceActivity")]
        pub device_activity: Option<Vec<super::device_activity::Data>>,
    }
    impl Data {
        pub fn user(&self) -> Result<&super::user::Data, &'static str> {
            self.user
                .as_ref()
                .ok_or("Attempted to acccess 'user' but did not fetch it using the .with() syntax")
                .map(|v| v.as_ref())
        }
        pub fn device_activity(&self) -> Result<&Vec<super::device_activity::Data>, &'static str> {
            self . device_activity . as_ref () . ok_or ("Attempted to acccess 'device_activity' but did not fetch it using the .with() syntax")
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        User(super::user::UniqueArgs),
        DeviceActivity(super::device_activity::ManyArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::User(args) => {
                    let mut selections = super::user::_outputs();
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    let mut builder = ::prisma_client_rust::Selection::builder("User");
                    builder.nested_selections(selections);
                    builder.build()
                }
                Self::DeviceActivity(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(super::device_activity::_outputs());
                    let mut builder = ::prisma_client_rust::Selection::builder("DeviceActivity");
                    builder
                        .nested_selections(nested_selections)
                        .set_arguments(arguments);
                    builder.build()
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(String),
        SetUpdatedAt(chrono::DateTime<chrono::FixedOffset>),
        SetCreatedAt(chrono::DateTime<chrono::FixedOffset>),
        SetName(String),
        SetUserId(String),
        ConnectUser(super::user::UniqueWhereParam),
        ConnectDeviceActivity(Vec<super::device_activity::UniqueWhereParam>),
        DisconnectDeviceActivity(Vec<super::device_activity::UniqueWhereParam>),
        SetDeviceActivity(Vec<super::device_activity::UniqueWhereParam>),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                SetParam::SetId(value) => ("ID".to_string(), PrismaValue::String(value)),
                SetParam::SetUpdatedAt(value) => {
                    ("UpdatedAt".to_string(), PrismaValue::DateTime(value))
                }
                SetParam::SetCreatedAt(value) => {
                    ("CreatedAt".to_string(), PrismaValue::DateTime(value))
                }
                SetParam::SetName(value) => ("Name".to_string(), PrismaValue::String(value)),
                SetParam::SetUserId(value) => ("UserId".to_string(), PrismaValue::String(value)),
                SetParam::ConnectUser(where_param) => (
                    "User".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::user::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectDeviceActivity(where_params) => (
                    "DeviceActivity".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::device_activity::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectDeviceActivity(where_params) => (
                    "DeviceActivity".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::device_activity::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetDeviceActivity(where_params) => (
                    "DeviceActivity".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::device_activity::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(Direction),
        UpdatedAt(Direction),
        CreatedAt(Direction),
        Name(Direction),
        UserId(Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    "ID".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::UpdatedAt(direction) => (
                    "UpdatedAt".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::CreatedAt(direction) => (
                    "CreatedAt".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Name(direction) => (
                    "Name".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::UserId(direction) => (
                    "UserId".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum Cursor {
        Id(String),
        Name(String),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for Cursor {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(cursor) => ("ID".to_string(), PrismaValue::String(cursor)),
                Self::Name(cursor) => ("Name".to_string(), PrismaValue::String(cursor)),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        IdEquals(String),
        IdInVec(Vec<String>),
        IdNotInVec(Vec<String>),
        IdLt(String),
        IdLte(String),
        IdGt(String),
        IdGte(String),
        IdContains(String),
        IdStartsWith(String),
        IdEndsWith(String),
        IdMode(QueryMode),
        IdNot(String),
        UpdatedAtEquals(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        UpdatedAtNotInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        UpdatedAtLt(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtLte(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtGt(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtGte(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtNot(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtEquals(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        CreatedAtNotInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        CreatedAtLt(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtLte(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtGt(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtGte(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtNot(chrono::DateTime<chrono::FixedOffset>),
        NameEquals(String),
        NameInVec(Vec<String>),
        NameNotInVec(Vec<String>),
        NameLt(String),
        NameLte(String),
        NameGt(String),
        NameGte(String),
        NameContains(String),
        NameStartsWith(String),
        NameEndsWith(String),
        NameMode(QueryMode),
        NameNot(String),
        UserIdEquals(String),
        UserIdInVec(Vec<String>),
        UserIdNotInVec(Vec<String>),
        UserIdLt(String),
        UserIdLte(String),
        UserIdGt(String),
        UserIdGte(String),
        UserIdContains(String),
        UserIdStartsWith(String),
        UserIdEndsWith(String),
        UserIdMode(QueryMode),
        UserIdNot(String),
        UserIs(Vec<super::user::WhereParam>),
        UserIsNot(Vec<super::user::WhereParam>),
        DeviceActivitySome(Vec<super::device_activity::WhereParam>),
        DeviceActivityEvery(Vec<super::device_activity::WhereParam>),
        DeviceActivityNone(Vec<super::device_activity::WhereParam>),
    }
    impl Into<::prisma_client_rust::SerializedWhere> for WhereParam {
        fn into(self) -> ::prisma_client_rust::SerializedWhere {
            match self {
                Self::Not(value) => ::prisma_client_rust::SerializedWhere::new(
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        value
                            .into_iter()
                            .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                            .map(Into::into)
                            .collect(),
                    ),
                ),
                Self::Or(value) => ::prisma_client_rust::SerializedWhere::new(
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => ::prisma_client_rust::SerializedWhere::new(
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        value
                            .into_iter()
                            .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                            .map(Into::into)
                            .collect(),
                    ),
                ),
                Self::IdEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ID",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ID",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::IdNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ID",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::IdLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ID",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ID",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ID",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ID",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdContains(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ID",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdStartsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ID",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdEndsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ID",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdMode(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ID",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::IdNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ID",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UpdatedAtEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "UpdatedAt",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "UpdatedAt",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::UpdatedAtNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "UpdatedAt",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::UpdatedAtLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "UpdatedAt",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "UpdatedAt",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "UpdatedAt",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "UpdatedAt",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "UpdatedAt",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "CreatedAt",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "CreatedAt",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::CreatedAtNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "CreatedAt",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::CreatedAtLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "CreatedAt",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "CreatedAt",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "CreatedAt",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "CreatedAt",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "CreatedAt",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::NameEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "Name",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::NameInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "Name",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::NameNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "Name",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::NameLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "Name",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::NameLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "Name",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::NameGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "Name",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::NameGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "Name",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::NameContains(value) => ::prisma_client_rust::SerializedWhere::new(
                    "Name",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::NameStartsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "Name",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::NameEndsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "Name",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::NameMode(value) => ::prisma_client_rust::SerializedWhere::new(
                    "Name",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::NameNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "Name",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "UserId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "UserId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::UserIdNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "UserId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::UserIdLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "UserId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "UserId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "UserId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "UserId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdContains(value) => ::prisma_client_rust::SerializedWhere::new(
                    "UserId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdStartsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "UserId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdEndsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "UserId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdMode(value) => ::prisma_client_rust::SerializedWhere::new(
                    "UserId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::UserIdNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "UserId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIs(where_params) => ::prisma_client_rust::SerializedWhere::new(
                    "User",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::UserIsNot(where_params) => ::prisma_client_rust::SerializedWhere::new(
                    "User",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::DeviceActivitySome(where_params) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "DeviceActivity",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "some".to_string(),
                            ::prisma_client_rust::PrismaValue::Object(
                                where_params
                                    .into_iter()
                                    .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                    .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                    .collect(),
                            ),
                        )]),
                    )
                }
                Self::DeviceActivityEvery(where_params) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "DeviceActivity",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "every".to_string(),
                            ::prisma_client_rust::PrismaValue::Object(
                                where_params
                                    .into_iter()
                                    .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                    .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                    .collect(),
                            ),
                        )]),
                    )
                }
                Self::DeviceActivityNone(where_params) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "DeviceActivity",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "none".to_string(),
                            ::prisma_client_rust::PrismaValue::Object(
                                where_params
                                    .into_iter()
                                    .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                    .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                    .collect(),
                            ),
                        )]),
                    )
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        NameEquals(String),
        IdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::NameEquals(value) => Self::NameEquals(value),
                UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
            }
        }
    }
    impl From<Operator<Self>> for WhereParam {
        fn from(op: Operator<Self>) -> Self {
            match op {
                Operator::Not(value) => Self::Not(value),
                Operator::And(value) => Self::And(value),
                Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<WithParam>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<WhereParam, WithParam, OrderByParam, Cursor>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, WhereParam, OrderByParam, Cursor>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, SetParam, WithParam, Data>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, SetParam>;
    pub type FindUnique<'a> =
        ::prisma_client_rust::FindUnique<'a, WhereParam, WithParam, SetParam, Data>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<
        'a,
        WhereParam,
        WithParam,
        OrderByParam,
        Cursor,
        SetParam,
        Data,
    >;
    pub type FindFirst<'a> =
        ::prisma_client_rust::FindFirst<'a, WhereParam, WithParam, OrderByParam, Cursor, Data>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, WhereParam, WithParam, SetParam, Data>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, WhereParam, SetParam>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, WhereParam, SetParam, WithParam, Data>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, WhereParam, WithParam, Data>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, WhereParam>;
    pub struct Actions<'a> {
        pub client: &'a PrismaClient,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("Activity", _outputs()),
                _where.into(),
            )
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("Activity", _outputs()),
                _where,
            )
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("Activity", _outputs()),
                _where,
            )
        }
        pub fn create(
            self,
            id: String,
            name: String,
            user: super::user::UniqueWhereParam,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.push(id::set(id));
            _params.push(name::set(name));
            _params.push(user::link(user));
            Create::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("Activity", _outputs()),
                _params,
            )
        }
        pub fn create_many(
            self,
            data: Vec<(String, String, super::user::UniqueWhereParam, Vec<SetParam>)>,
        ) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(id, name, user, mut _params)| {
                    _params.push(id::set(id));
                    _params.push(name::set(name));
                    _params.push(user::link(user));
                    _params
                })
                .collect();
            CreateMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("Activity", _outputs()),
                data,
            )
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("Activity", _outputs()),
                _where.into(),
                _params,
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("Activity", _outputs()),
                _where,
                _params,
            )
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (id, name, user, mut _params): (
                String,
                String,
                super::user::UniqueWhereParam,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.push(id::set(id));
            _params.push(name::set(name));
            _params.push(user::link(user));
            Upsert::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("Activity", _outputs()),
                _where.into(),
                _params,
                _update,
            )
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("Activity", _outputs()),
                _where.into(),
                vec![],
            )
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("Activity", _outputs()),
                _where.into(),
            )
        }
        pub fn count(self) -> Count<'a> {
            Count::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("Activity", _outputs()),
                vec![],
            )
        }
    }
}
pub mod device {
    use super::_prisma::*;
    use super::*;
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn cursor(cursor: String) -> Cursor {
            Cursor::Id(cursor)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::IdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::IdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::IdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::IdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::IdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::IdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::IdEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::IdMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::IdNot(value)
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetId(value.0)
            }
        }
    }
    pub mod name {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::NameEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Name(direction)
        }
        pub fn cursor(cursor: String) -> Cursor {
            Cursor::Name(cursor)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::NameInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::NameNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::NameLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::NameLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::NameGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::NameGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::NameContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::NameStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::NameEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::NameMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::NameNot(value)
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetName(value.0)
            }
        }
    }
    pub mod device_activity {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn some(value: Vec<device_activity::WhereParam>) -> WhereParam {
            WhereParam::DeviceActivitySome(value)
        }
        pub fn every(value: Vec<device_activity::WhereParam>) -> WhereParam {
            WhereParam::DeviceActivityEvery(value)
        }
        pub fn none(value: Vec<device_activity::WhereParam>) -> WhereParam {
            WhereParam::DeviceActivityNone(value)
        }
        pub struct Fetch(pub device_activity::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<device_activity::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: impl Into<device_activity::OrderByParam>) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: impl Into<device_activity::Cursor>) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::DeviceActivity(fetch.0)
            }
        }
        pub fn fetch(params: Vec<device_activity::WhereParam>) -> Fetch {
            Fetch(device_activity::ManyArgs::new(params))
        }
        pub fn link<T: From<Link>>(params: Vec<device_activity::UniqueWhereParam>) -> T {
            Link(params).into()
        }
        pub fn unlink(params: Vec<device_activity::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectDeviceActivity(params)
        }
        pub fn set(params: Vec<device_activity::UniqueWhereParam>) -> SetParam {
            SetParam::SetDeviceActivity(params)
        }
        pub struct Link(pub Vec<device_activity::UniqueWhereParam>);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::ConnectDeviceActivity(value.0)
            }
        }
    }
    pub fn _outputs() -> Vec<::prisma_client_rust::Selection> {
        ["ID", "Name"]
            .into_iter()
            .map(|o| {
                let builder = ::prisma_client_rust::Selection::builder(o);
                builder.build()
            })
            .collect()
    }
    pub fn create(
        id: String,
        name: String,
        _params: Vec<SetParam>,
    ) -> (String, String, Vec<SetParam>) {
        (id, name, _params)
    }
    #[macro_export]
    macro_rules ! _select_device { ($ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ ({ $ ($ selections : tt) + }) ?) +) => { { $ crate :: prisma :: device :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ ({ $ ($ selections) + }) ?) +) ; Select ($ crate :: prisma :: device :: select ! (@ select_fields_to_selections ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ ({ $ ($ selections) + }) ?) +)) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ ({ $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , name , device_activity } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [derive (:: serde :: Deserialize , :: serde :: Serialize)] # [allow (warnings)] pub struct Data { $ ($ field : $ crate :: prisma :: device :: select ! (@ field_type ; $ field $ ({ $ ($ selections) + }) ?) ,) + } $ ($ (pub mod $ field { $ crate :: prisma :: device :: select ! (@ field_module ; $ field { $ ($ selections) + }) ; }) ?) + pub struct Select (pub Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType < $ crate :: prisma :: device :: Data > for Select { type Data = Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } } ; (@ field_type ; id) => { String } ; (@ field_type ; name) => { String } ; (@ field_type ; device_activity { $ ($ selections : tt) + }) => { Vec < device_activity :: Data > } ; (@ field_type ; device_activity) => { Vec < crate :: prisma :: device_activity :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model device)) } ; (@ field_module ; device_activity { $ ($ selections : tt) + }) => { $ crate :: prisma :: device_activity :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ select_fields_to_selections ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ ({ $ ($ selections : tt) + }) ?) +) => { vec ! [$ ($ crate :: prisma :: device :: select ! (@ select_field_to_selection ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ ({ $ ($ selections) + }) ?)) , +] } ; (@ select_field_to_selection ; id) => { :: prisma_client_rust :: Selection :: builder ("ID") . build () } ; (@ select_field_to_selection ; name) => { :: prisma_client_rust :: Selection :: builder ("Name") . build () } ; (@ select_field_to_selection ; device_activity $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? { $ ($ selections : tt) + }) => { { # [allow (warnings)] let mut selection = :: prisma_client_rust :: Selection :: builder ("DeviceActivity") ; $ (let args = $ crate :: prisma :: device_activity :: ManyArgs :: new ($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) * ; selection . set_arguments (args . to_graphql () . 0) ;) ? selection . nested_selections ($ crate :: prisma :: device_activity :: select ! (@ select_fields_to_selections ; $ ($ selections) +)) ; selection . build () } } ; (@ select_field_to_selection ; device_activity $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { # [allow (warnings)] let mut selection = :: prisma_client_rust :: Selection :: builder ("DeviceActivity") ; $ (let args = $ crate :: prisma :: device_activity :: ManyArgs :: new ($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) * ; selection . set_arguments (args . to_graphql () . 0) ;) ? selection . nested_selections ($ crate :: prisma :: device_activity :: _outputs ()) ; selection . build () } } ; (@ select_field_to_selection ; $ ($ tokens : tt) *) => { :: prisma_client_rust :: Selection :: builder ("") . build () } ; }
    pub use _select_device as select;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "ID")]
        pub id: String,
        #[serde(rename = "Name")]
        pub name: String,
        #[serde(rename = "DeviceActivity")]
        pub device_activity: Option<Vec<super::device_activity::Data>>,
    }
    impl Data {
        pub fn device_activity(&self) -> Result<&Vec<super::device_activity::Data>, &'static str> {
            self . device_activity . as_ref () . ok_or ("Attempted to acccess 'device_activity' but did not fetch it using the .with() syntax")
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        DeviceActivity(super::device_activity::ManyArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::DeviceActivity(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(super::device_activity::_outputs());
                    let mut builder = ::prisma_client_rust::Selection::builder("DeviceActivity");
                    builder
                        .nested_selections(nested_selections)
                        .set_arguments(arguments);
                    builder.build()
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(String),
        SetName(String),
        ConnectDeviceActivity(Vec<super::device_activity::UniqueWhereParam>),
        DisconnectDeviceActivity(Vec<super::device_activity::UniqueWhereParam>),
        SetDeviceActivity(Vec<super::device_activity::UniqueWhereParam>),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                SetParam::SetId(value) => ("ID".to_string(), PrismaValue::String(value)),
                SetParam::SetName(value) => ("Name".to_string(), PrismaValue::String(value)),
                SetParam::ConnectDeviceActivity(where_params) => (
                    "DeviceActivity".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::device_activity::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectDeviceActivity(where_params) => (
                    "DeviceActivity".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::device_activity::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetDeviceActivity(where_params) => (
                    "DeviceActivity".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::device_activity::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(Direction),
        Name(Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    "ID".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Name(direction) => (
                    "Name".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum Cursor {
        Id(String),
        Name(String),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for Cursor {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(cursor) => ("ID".to_string(), PrismaValue::String(cursor)),
                Self::Name(cursor) => ("Name".to_string(), PrismaValue::String(cursor)),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        IdEquals(String),
        IdInVec(Vec<String>),
        IdNotInVec(Vec<String>),
        IdLt(String),
        IdLte(String),
        IdGt(String),
        IdGte(String),
        IdContains(String),
        IdStartsWith(String),
        IdEndsWith(String),
        IdMode(QueryMode),
        IdNot(String),
        NameEquals(String),
        NameInVec(Vec<String>),
        NameNotInVec(Vec<String>),
        NameLt(String),
        NameLte(String),
        NameGt(String),
        NameGte(String),
        NameContains(String),
        NameStartsWith(String),
        NameEndsWith(String),
        NameMode(QueryMode),
        NameNot(String),
        DeviceActivitySome(Vec<super::device_activity::WhereParam>),
        DeviceActivityEvery(Vec<super::device_activity::WhereParam>),
        DeviceActivityNone(Vec<super::device_activity::WhereParam>),
    }
    impl Into<::prisma_client_rust::SerializedWhere> for WhereParam {
        fn into(self) -> ::prisma_client_rust::SerializedWhere {
            match self {
                Self::Not(value) => ::prisma_client_rust::SerializedWhere::new(
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        value
                            .into_iter()
                            .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                            .map(Into::into)
                            .collect(),
                    ),
                ),
                Self::Or(value) => ::prisma_client_rust::SerializedWhere::new(
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => ::prisma_client_rust::SerializedWhere::new(
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        value
                            .into_iter()
                            .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                            .map(Into::into)
                            .collect(),
                    ),
                ),
                Self::IdEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ID",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ID",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::IdNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ID",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::IdLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ID",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ID",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ID",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ID",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdContains(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ID",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdStartsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ID",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdEndsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ID",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdMode(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ID",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::IdNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ID",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::NameEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "Name",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::NameInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "Name",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::NameNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "Name",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::NameLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "Name",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::NameLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "Name",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::NameGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "Name",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::NameGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "Name",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::NameContains(value) => ::prisma_client_rust::SerializedWhere::new(
                    "Name",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::NameStartsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "Name",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::NameEndsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "Name",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::NameMode(value) => ::prisma_client_rust::SerializedWhere::new(
                    "Name",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::NameNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "Name",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::DeviceActivitySome(where_params) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "DeviceActivity",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "some".to_string(),
                            ::prisma_client_rust::PrismaValue::Object(
                                where_params
                                    .into_iter()
                                    .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                    .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                    .collect(),
                            ),
                        )]),
                    )
                }
                Self::DeviceActivityEvery(where_params) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "DeviceActivity",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "every".to_string(),
                            ::prisma_client_rust::PrismaValue::Object(
                                where_params
                                    .into_iter()
                                    .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                    .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                    .collect(),
                            ),
                        )]),
                    )
                }
                Self::DeviceActivityNone(where_params) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "DeviceActivity",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "none".to_string(),
                            ::prisma_client_rust::PrismaValue::Object(
                                where_params
                                    .into_iter()
                                    .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                    .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                    .collect(),
                            ),
                        )]),
                    )
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        NameEquals(String),
        IdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::NameEquals(value) => Self::NameEquals(value),
                UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
            }
        }
    }
    impl From<Operator<Self>> for WhereParam {
        fn from(op: Operator<Self>) -> Self {
            match op {
                Operator::Not(value) => Self::Not(value),
                Operator::And(value) => Self::And(value),
                Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<WithParam>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<WhereParam, WithParam, OrderByParam, Cursor>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, WhereParam, OrderByParam, Cursor>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, SetParam, WithParam, Data>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, SetParam>;
    pub type FindUnique<'a> =
        ::prisma_client_rust::FindUnique<'a, WhereParam, WithParam, SetParam, Data>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<
        'a,
        WhereParam,
        WithParam,
        OrderByParam,
        Cursor,
        SetParam,
        Data,
    >;
    pub type FindFirst<'a> =
        ::prisma_client_rust::FindFirst<'a, WhereParam, WithParam, OrderByParam, Cursor, Data>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, WhereParam, WithParam, SetParam, Data>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, WhereParam, SetParam>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, WhereParam, SetParam, WithParam, Data>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, WhereParam, WithParam, Data>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, WhereParam>;
    pub struct Actions<'a> {
        pub client: &'a PrismaClient,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("Device", _outputs()),
                _where.into(),
            )
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("Device", _outputs()),
                _where,
            )
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("Device", _outputs()),
                _where,
            )
        }
        pub fn create(self, id: String, name: String, mut _params: Vec<SetParam>) -> Create<'a> {
            _params.push(id::set(id));
            _params.push(name::set(name));
            Create::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("Device", _outputs()),
                _params,
            )
        }
        pub fn create_many(self, data: Vec<(String, String, Vec<SetParam>)>) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(id, name, mut _params)| {
                    _params.push(id::set(id));
                    _params.push(name::set(name));
                    _params
                })
                .collect();
            CreateMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("Device", _outputs()),
                data,
            )
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("Device", _outputs()),
                _where.into(),
                _params,
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("Device", _outputs()),
                _where,
                _params,
            )
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (id, name, mut _params): (String, String, Vec<SetParam>),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.push(id::set(id));
            _params.push(name::set(name));
            Upsert::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("Device", _outputs()),
                _where.into(),
                _params,
                _update,
            )
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("Device", _outputs()),
                _where.into(),
                vec![],
            )
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("Device", _outputs()),
                _where.into(),
            )
        }
        pub fn count(self) -> Count<'a> {
            Count::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("Device", _outputs()),
                vec![],
            )
        }
    }
}
pub mod device_activity {
    use super::_prisma::*;
    use super::*;
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn cursor(cursor: String) -> Cursor {
            Cursor::Id(cursor)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::IdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::IdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::IdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::IdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::IdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::IdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::IdEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::IdMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::IdNot(value)
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetId(value.0)
            }
        }
    }
    pub mod updated_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: chrono::DateTime<chrono::FixedOffset>) -> T {
            Set(value).into()
        }
        pub fn equals(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::UpdatedAt(direction)
        }
        pub fn in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::UpdatedAtInVec(value)
        }
        pub fn not_in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::UpdatedAtNotInVec(value)
        }
        pub fn lt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtLt(value)
        }
        pub fn lte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtLte(value)
        }
        pub fn gt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtGt(value)
        }
        pub fn gte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtGte(value)
        }
        pub fn not(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtNot(value)
        }
        pub struct Set(pub chrono::DateTime<chrono::FixedOffset>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetUpdatedAt(value.0)
            }
        }
    }
    pub mod created_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: chrono::DateTime<chrono::FixedOffset>) -> T {
            Set(value).into()
        }
        pub fn equals(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::CreatedAt(direction)
        }
        pub fn in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::CreatedAtInVec(value)
        }
        pub fn not_in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::CreatedAtNotInVec(value)
        }
        pub fn lt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtLt(value)
        }
        pub fn lte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtLte(value)
        }
        pub fn gt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtGt(value)
        }
        pub fn gte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtGte(value)
        }
        pub fn not(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtNot(value)
        }
        pub struct Set(pub chrono::DateTime<chrono::FixedOffset>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetCreatedAt(value.0)
            }
        }
    }
    pub mod activity_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::ActivityIdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::ActivityId(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::ActivityIdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::ActivityIdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::ActivityIdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::ActivityIdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::ActivityIdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::ActivityIdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::ActivityIdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::ActivityIdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::ActivityIdEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::ActivityIdMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::ActivityIdNot(value)
        }
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetActivityId(value.0)
            }
        }
    }
    pub mod device_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::DeviceIdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::DeviceId(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::DeviceIdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::DeviceIdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::DeviceIdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::DeviceIdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::DeviceIdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::DeviceIdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::DeviceIdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::DeviceIdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::DeviceIdEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::DeviceIdMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::DeviceIdNot(value)
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetDeviceId(value.0)
            }
        }
    }
    pub mod activity {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn is(value: Vec<activity::WhereParam>) -> WhereParam {
            WhereParam::ActivityIs(value)
        }
        pub fn is_not(value: Vec<activity::WhereParam>) -> WhereParam {
            WhereParam::ActivityIsNot(value)
        }
        pub struct Fetch(pub activity::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<activity::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::Activity(fetch.0)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(activity::UniqueArgs::new())
        }
        pub fn link<T: From<Link>>(value: activity::UniqueWhereParam) -> T {
            Link(value).into()
        }
        pub fn unlink() -> SetParam {
            SetParam::DisconnectActivity
        }
        pub struct Link(activity::UniqueWhereParam);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::ConnectActivity(value.0)
            }
        }
    }
    pub mod device {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn is(value: Vec<device::WhereParam>) -> WhereParam {
            WhereParam::DeviceIs(value)
        }
        pub fn is_not(value: Vec<device::WhereParam>) -> WhereParam {
            WhereParam::DeviceIsNot(value)
        }
        pub struct Fetch(pub device::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<device::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::Device(fetch.0)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(device::UniqueArgs::new())
        }
        pub fn link<T: From<Link>>(value: device::UniqueWhereParam) -> T {
            Link(value).into()
        }
        pub struct Link(device::UniqueWhereParam);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::ConnectDevice(value.0)
            }
        }
    }
    pub fn _outputs() -> Vec<::prisma_client_rust::Selection> {
        ["ID", "UpdatedAt", "CreatedAt", "ActivityId", "DeviceId"]
            .into_iter()
            .map(|o| {
                let builder = ::prisma_client_rust::Selection::builder(o);
                builder.build()
            })
            .collect()
    }
    pub fn create(
        id: String,
        device: super::device::UniqueWhereParam,
        _params: Vec<SetParam>,
    ) -> (String, super::device::UniqueWhereParam, Vec<SetParam>) {
        (id, device, _params)
    }
    #[macro_export]
    macro_rules ! _select_device_activity { ($ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ ({ $ ($ selections : tt) + }) ?) +) => { { $ crate :: prisma :: device_activity :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ ({ $ ($ selections) + }) ?) +) ; Select ($ crate :: prisma :: device_activity :: select ! (@ select_fields_to_selections ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ ({ $ ($ selections) + }) ?) +)) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ ({ $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , updated_at , created_at , activity_id , device_id , activity , device } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [derive (:: serde :: Deserialize , :: serde :: Serialize)] # [allow (warnings)] pub struct Data { $ ($ field : $ crate :: prisma :: device_activity :: select ! (@ field_type ; $ field $ ({ $ ($ selections) + }) ?) ,) + } $ ($ (pub mod $ field { $ crate :: prisma :: device_activity :: select ! (@ field_module ; $ field { $ ($ selections) + }) ; }) ?) + pub struct Select (pub Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType < $ crate :: prisma :: device_activity :: Data > for Select { type Data = Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } } ; (@ field_type ; id) => { String } ; (@ field_type ; updated_at) => { chrono :: DateTime < chrono :: FixedOffset > } ; (@ field_type ; created_at) => { chrono :: DateTime < chrono :: FixedOffset > } ; (@ field_type ; activity_id) => { Option < String > } ; (@ field_type ; device_id) => { String } ; (@ field_type ; activity { $ ($ selections : tt) + }) => { Option < activity :: Data > } ; (@ field_type ; activity) => { Option < crate :: prisma :: activity :: Data > } ; (@ field_type ; device { $ ($ selections : tt) + }) => { device :: Data } ; (@ field_type ; device) => { crate :: prisma :: device :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model device_activity)) } ; (@ field_module ; activity { $ ($ selections : tt) + }) => { $ crate :: prisma :: activity :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; device { $ ($ selections : tt) + }) => { $ crate :: prisma :: device :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ select_fields_to_selections ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ ({ $ ($ selections : tt) + }) ?) +) => { vec ! [$ ($ crate :: prisma :: device_activity :: select ! (@ select_field_to_selection ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ ({ $ ($ selections) + }) ?)) , +] } ; (@ select_field_to_selection ; id) => { :: prisma_client_rust :: Selection :: builder ("ID") . build () } ; (@ select_field_to_selection ; updated_at) => { :: prisma_client_rust :: Selection :: builder ("UpdatedAt") . build () } ; (@ select_field_to_selection ; created_at) => { :: prisma_client_rust :: Selection :: builder ("CreatedAt") . build () } ; (@ select_field_to_selection ; activity_id) => { :: prisma_client_rust :: Selection :: builder ("ActivityId") . build () } ; (@ select_field_to_selection ; device_id) => { :: prisma_client_rust :: Selection :: builder ("DeviceId") . build () } ; (@ select_field_to_selection ; activity $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? { $ ($ selections : tt) + }) => { { # [allow (warnings)] let mut selection = :: prisma_client_rust :: Selection :: builder ("Activity") ; $ (let args = $ crate :: prisma :: activity :: ManyArgs :: new ($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) * ; selection . set_arguments (args . to_graphql () . 0) ;) ? selection . nested_selections ($ crate :: prisma :: activity :: select ! (@ select_fields_to_selections ; $ ($ selections) +)) ; selection . build () } } ; (@ select_field_to_selection ; activity $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { # [allow (warnings)] let mut selection = :: prisma_client_rust :: Selection :: builder ("Activity") ; $ (let args = $ crate :: prisma :: activity :: ManyArgs :: new ($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) * ; selection . set_arguments (args . to_graphql () . 0) ;) ? selection . nested_selections ($ crate :: prisma :: activity :: _outputs ()) ; selection . build () } } ; (@ select_field_to_selection ; device $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? { $ ($ selections : tt) + }) => { { # [allow (warnings)] let mut selection = :: prisma_client_rust :: Selection :: builder ("Device") ; $ (let args = $ crate :: prisma :: device :: ManyArgs :: new ($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) * ; selection . set_arguments (args . to_graphql () . 0) ;) ? selection . nested_selections ($ crate :: prisma :: device :: select ! (@ select_fields_to_selections ; $ ($ selections) +)) ; selection . build () } } ; (@ select_field_to_selection ; device $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { # [allow (warnings)] let mut selection = :: prisma_client_rust :: Selection :: builder ("Device") ; $ (let args = $ crate :: prisma :: device :: ManyArgs :: new ($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) * ; selection . set_arguments (args . to_graphql () . 0) ;) ? selection . nested_selections ($ crate :: prisma :: device :: _outputs ()) ; selection . build () } } ; (@ select_field_to_selection ; $ ($ tokens : tt) *) => { :: prisma_client_rust :: Selection :: builder ("") . build () } ; }
    pub use _select_device_activity as select;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "ID")]
        pub id: String,
        #[serde(rename = "UpdatedAt")]
        pub updated_at: chrono::DateTime<chrono::FixedOffset>,
        #[serde(rename = "CreatedAt")]
        pub created_at: chrono::DateTime<chrono::FixedOffset>,
        #[serde(rename = "ActivityId")]
        pub activity_id: Option<String>,
        #[serde(rename = "DeviceId")]
        pub device_id: String,
        #[serde(
            rename = "Activity",
            default,
            skip_serializing_if = "Option::is_none",
            with = "prisma_client_rust::serde::double_option"
        )]
        pub activity: Option<Option<Box<super::activity::Data>>>,
        #[serde(rename = "Device")]
        pub device: Option<Box<super::device::Data>>,
    }
    impl Data {
        pub fn activity(&self) -> Result<Option<&super::activity::Data>, &'static str> {
            self.activity
                .as_ref()
                .ok_or(
                    "Attempted to acccess 'activity' but did not fetch it using the .with() syntax",
                )
                .map(|v| v.as_ref().map(|v| v.as_ref()))
        }
        pub fn device(&self) -> Result<&super::device::Data, &'static str> {
            self.device
                .as_ref()
                .ok_or(
                    "Attempted to acccess 'device' but did not fetch it using the .with() syntax",
                )
                .map(|v| v.as_ref())
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Activity(super::activity::UniqueArgs),
        Device(super::device::UniqueArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Activity(args) => {
                    let mut selections = super::activity::_outputs();
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    let mut builder = ::prisma_client_rust::Selection::builder("Activity");
                    builder.nested_selections(selections);
                    builder.build()
                }
                Self::Device(args) => {
                    let mut selections = super::device::_outputs();
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    let mut builder = ::prisma_client_rust::Selection::builder("Device");
                    builder.nested_selections(selections);
                    builder.build()
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(String),
        SetUpdatedAt(chrono::DateTime<chrono::FixedOffset>),
        SetCreatedAt(chrono::DateTime<chrono::FixedOffset>),
        SetActivityId(Option<String>),
        SetDeviceId(String),
        ConnectActivity(super::activity::UniqueWhereParam),
        DisconnectActivity,
        ConnectDevice(super::device::UniqueWhereParam),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                SetParam::SetId(value) => ("ID".to_string(), PrismaValue::String(value)),
                SetParam::SetUpdatedAt(value) => {
                    ("UpdatedAt".to_string(), PrismaValue::DateTime(value))
                }
                SetParam::SetCreatedAt(value) => {
                    ("CreatedAt".to_string(), PrismaValue::DateTime(value))
                }
                SetParam::SetActivityId(value) => (
                    "ActivityId".to_string(),
                    value
                        .map(|value| PrismaValue::String(value))
                        .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::SetDeviceId(value) => {
                    ("DeviceId".to_string(), PrismaValue::String(value))
                }
                SetParam::ConnectActivity(where_param) => (
                    "Activity".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::activity::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectActivity => (
                    "Activity".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::Boolean(true),
                    )]),
                ),
                SetParam::ConnectDevice(where_param) => (
                    "Device".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::device::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(Direction),
        UpdatedAt(Direction),
        CreatedAt(Direction),
        ActivityId(Direction),
        DeviceId(Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    "ID".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::UpdatedAt(direction) => (
                    "UpdatedAt".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::CreatedAt(direction) => (
                    "CreatedAt".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::ActivityId(direction) => (
                    "ActivityId".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::DeviceId(direction) => (
                    "DeviceId".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum Cursor {
        Id(String),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for Cursor {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(cursor) => ("ID".to_string(), PrismaValue::String(cursor)),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        IdEquals(String),
        IdInVec(Vec<String>),
        IdNotInVec(Vec<String>),
        IdLt(String),
        IdLte(String),
        IdGt(String),
        IdGte(String),
        IdContains(String),
        IdStartsWith(String),
        IdEndsWith(String),
        IdMode(QueryMode),
        IdNot(String),
        UpdatedAtEquals(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        UpdatedAtNotInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        UpdatedAtLt(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtLte(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtGt(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtGte(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtNot(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtEquals(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        CreatedAtNotInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        CreatedAtLt(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtLte(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtGt(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtGte(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtNot(chrono::DateTime<chrono::FixedOffset>),
        ActivityIdEquals(Option<String>),
        ActivityIdInVec(Vec<String>),
        ActivityIdNotInVec(Vec<String>),
        ActivityIdLt(String),
        ActivityIdLte(String),
        ActivityIdGt(String),
        ActivityIdGte(String),
        ActivityIdContains(String),
        ActivityIdStartsWith(String),
        ActivityIdEndsWith(String),
        ActivityIdMode(QueryMode),
        ActivityIdNot(String),
        DeviceIdEquals(String),
        DeviceIdInVec(Vec<String>),
        DeviceIdNotInVec(Vec<String>),
        DeviceIdLt(String),
        DeviceIdLte(String),
        DeviceIdGt(String),
        DeviceIdGte(String),
        DeviceIdContains(String),
        DeviceIdStartsWith(String),
        DeviceIdEndsWith(String),
        DeviceIdMode(QueryMode),
        DeviceIdNot(String),
        ActivityIs(Vec<super::activity::WhereParam>),
        ActivityIsNot(Vec<super::activity::WhereParam>),
        DeviceIs(Vec<super::device::WhereParam>),
        DeviceIsNot(Vec<super::device::WhereParam>),
    }
    impl Into<::prisma_client_rust::SerializedWhere> for WhereParam {
        fn into(self) -> ::prisma_client_rust::SerializedWhere {
            match self {
                Self::Not(value) => ::prisma_client_rust::SerializedWhere::new(
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        value
                            .into_iter()
                            .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                            .map(Into::into)
                            .collect(),
                    ),
                ),
                Self::Or(value) => ::prisma_client_rust::SerializedWhere::new(
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => ::prisma_client_rust::SerializedWhere::new(
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        value
                            .into_iter()
                            .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                            .map(Into::into)
                            .collect(),
                    ),
                ),
                Self::IdEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ID",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ID",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::IdNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ID",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::IdLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ID",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ID",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ID",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ID",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdContains(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ID",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdStartsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ID",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdEndsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ID",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdMode(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ID",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::IdNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ID",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UpdatedAtEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "UpdatedAt",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "UpdatedAt",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::UpdatedAtNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "UpdatedAt",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::UpdatedAtLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "UpdatedAt",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "UpdatedAt",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "UpdatedAt",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "UpdatedAt",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "UpdatedAt",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "CreatedAt",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "CreatedAt",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::CreatedAtNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "CreatedAt",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::CreatedAtLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "CreatedAt",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "CreatedAt",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "CreatedAt",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "CreatedAt",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "CreatedAt",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::ActivityIdEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ActivityId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| PrismaValue::String(value))
                            .unwrap_or(PrismaValue::Null),
                    )]),
                ),
                Self::ActivityIdInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ActivityId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::ActivityIdNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ActivityId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::ActivityIdLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ActivityId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ActivityIdLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ActivityId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ActivityIdGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ActivityId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ActivityIdGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ActivityId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ActivityIdContains(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ActivityId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ActivityIdStartsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ActivityId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ActivityIdEndsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ActivityId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ActivityIdMode(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ActivityId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::ActivityIdNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ActivityId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::DeviceIdEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "DeviceId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::DeviceIdInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "DeviceId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::DeviceIdNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "DeviceId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::DeviceIdLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "DeviceId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::DeviceIdLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "DeviceId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::DeviceIdGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "DeviceId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::DeviceIdGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "DeviceId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::DeviceIdContains(value) => ::prisma_client_rust::SerializedWhere::new(
                    "DeviceId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::DeviceIdStartsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "DeviceId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::DeviceIdEndsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "DeviceId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::DeviceIdMode(value) => ::prisma_client_rust::SerializedWhere::new(
                    "DeviceId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::DeviceIdNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "DeviceId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ActivityIs(where_params) => ::prisma_client_rust::SerializedWhere::new(
                    "Activity",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ActivityIsNot(where_params) => ::prisma_client_rust::SerializedWhere::new(
                    "Activity",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::DeviceIs(where_params) => ::prisma_client_rust::SerializedWhere::new(
                    "Device",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::DeviceIsNot(where_params) => ::prisma_client_rust::SerializedWhere::new(
                    "Device",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        IdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
            }
        }
    }
    impl From<Operator<Self>> for WhereParam {
        fn from(op: Operator<Self>) -> Self {
            match op {
                Operator::Not(value) => Self::Not(value),
                Operator::And(value) => Self::And(value),
                Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<WithParam>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<WhereParam, WithParam, OrderByParam, Cursor>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, WhereParam, OrderByParam, Cursor>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, SetParam, WithParam, Data>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, SetParam>;
    pub type FindUnique<'a> =
        ::prisma_client_rust::FindUnique<'a, WhereParam, WithParam, SetParam, Data>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<
        'a,
        WhereParam,
        WithParam,
        OrderByParam,
        Cursor,
        SetParam,
        Data,
    >;
    pub type FindFirst<'a> =
        ::prisma_client_rust::FindFirst<'a, WhereParam, WithParam, OrderByParam, Cursor, Data>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, WhereParam, WithParam, SetParam, Data>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, WhereParam, SetParam>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, WhereParam, SetParam, WithParam, Data>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, WhereParam, WithParam, Data>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, WhereParam>;
    pub struct Actions<'a> {
        pub client: &'a PrismaClient,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("DeviceActivity", _outputs()),
                _where.into(),
            )
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("DeviceActivity", _outputs()),
                _where,
            )
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("DeviceActivity", _outputs()),
                _where,
            )
        }
        pub fn create(
            self,
            id: String,
            device: super::device::UniqueWhereParam,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.push(id::set(id));
            _params.push(device::link(device));
            Create::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("DeviceActivity", _outputs()),
                _params,
            )
        }
        pub fn create_many(
            self,
            data: Vec<(String, super::device::UniqueWhereParam, Vec<SetParam>)>,
        ) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(id, device, mut _params)| {
                    _params.push(id::set(id));
                    _params.push(device::link(device));
                    _params
                })
                .collect();
            CreateMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("DeviceActivity", _outputs()),
                data,
            )
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("DeviceActivity", _outputs()),
                _where.into(),
                _params,
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("DeviceActivity", _outputs()),
                _where,
                _params,
            )
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (id, device, mut _params): (String, super::device::UniqueWhereParam, Vec<SetParam>),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.push(id::set(id));
            _params.push(device::link(device));
            Upsert::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("DeviceActivity", _outputs()),
                _where.into(),
                _params,
                _update,
            )
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("DeviceActivity", _outputs()),
                _where.into(),
                vec![],
            )
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("DeviceActivity", _outputs()),
                _where.into(),
            )
        }
        pub fn count(self) -> Count<'a> {
            Count::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("DeviceActivity", _outputs()),
                vec![],
            )
        }
    }
}
pub mod user {
    use super::_prisma::*;
    use super::*;
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn cursor(cursor: String) -> Cursor {
            Cursor::Id(cursor)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::IdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::IdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::IdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::IdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::IdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::IdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::IdEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::IdMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::IdNot(value)
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetId(value.0)
            }
        }
    }
    pub mod name {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::NameEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Name(direction)
        }
        pub fn cursor(cursor: String) -> Cursor {
            Cursor::Name(cursor)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::NameInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::NameNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::NameLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::NameLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::NameGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::NameGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::NameContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::NameStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::NameEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::NameMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::NameNot(value)
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetName(value.0)
            }
        }
    }
    pub mod api_key {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::ApiKeyEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::ApiKey(direction)
        }
        pub fn cursor(cursor: String) -> Cursor {
            Cursor::ApiKey(cursor)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::ApiKeyInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::ApiKeyNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::ApiKeyLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::ApiKeyLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::ApiKeyGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::ApiKeyGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::ApiKeyContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::ApiKeyStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::ApiKeyEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::ApiKeyMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::ApiKeyNot(value)
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetApiKey(value.0)
            }
        }
    }
    pub mod activity {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn some(value: Vec<activity::WhereParam>) -> WhereParam {
            WhereParam::ActivitySome(value)
        }
        pub fn every(value: Vec<activity::WhereParam>) -> WhereParam {
            WhereParam::ActivityEvery(value)
        }
        pub fn none(value: Vec<activity::WhereParam>) -> WhereParam {
            WhereParam::ActivityNone(value)
        }
        pub struct Fetch(pub activity::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<activity::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: impl Into<activity::OrderByParam>) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: impl Into<activity::Cursor>) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::Activity(fetch.0)
            }
        }
        pub fn fetch(params: Vec<activity::WhereParam>) -> Fetch {
            Fetch(activity::ManyArgs::new(params))
        }
        pub fn link<T: From<Link>>(params: Vec<activity::UniqueWhereParam>) -> T {
            Link(params).into()
        }
        pub fn unlink(params: Vec<activity::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectActivity(params)
        }
        pub fn set(params: Vec<activity::UniqueWhereParam>) -> SetParam {
            SetParam::SetActivity(params)
        }
        pub struct Link(pub Vec<activity::UniqueWhereParam>);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::ConnectActivity(value.0)
            }
        }
    }
    pub fn _outputs() -> Vec<::prisma_client_rust::Selection> {
        ["ID", "Name", "ApiKey"]
            .into_iter()
            .map(|o| {
                let builder = ::prisma_client_rust::Selection::builder(o);
                builder.build()
            })
            .collect()
    }
    pub fn create(
        id: String,
        name: String,
        api_key: String,
        _params: Vec<SetParam>,
    ) -> (String, String, String, Vec<SetParam>) {
        (id, name, api_key, _params)
    }
    #[macro_export]
    macro_rules ! _select_user { ($ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ ({ $ ($ selections : tt) + }) ?) +) => { { $ crate :: prisma :: user :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ ({ $ ($ selections) + }) ?) +) ; Select ($ crate :: prisma :: user :: select ! (@ select_fields_to_selections ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ ({ $ ($ selections) + }) ?) +)) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ ({ $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , name , api_key , activity } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [derive (:: serde :: Deserialize , :: serde :: Serialize)] # [allow (warnings)] pub struct Data { $ ($ field : $ crate :: prisma :: user :: select ! (@ field_type ; $ field $ ({ $ ($ selections) + }) ?) ,) + } $ ($ (pub mod $ field { $ crate :: prisma :: user :: select ! (@ field_module ; $ field { $ ($ selections) + }) ; }) ?) + pub struct Select (pub Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType < $ crate :: prisma :: user :: Data > for Select { type Data = Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } } ; (@ field_type ; id) => { String } ; (@ field_type ; name) => { String } ; (@ field_type ; api_key) => { String } ; (@ field_type ; activity { $ ($ selections : tt) + }) => { Vec < activity :: Data > } ; (@ field_type ; activity) => { Vec < crate :: prisma :: activity :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model user)) } ; (@ field_module ; activity { $ ($ selections : tt) + }) => { $ crate :: prisma :: activity :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ select_fields_to_selections ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ ({ $ ($ selections : tt) + }) ?) +) => { vec ! [$ ($ crate :: prisma :: user :: select ! (@ select_field_to_selection ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ ({ $ ($ selections) + }) ?)) , +] } ; (@ select_field_to_selection ; id) => { :: prisma_client_rust :: Selection :: builder ("ID") . build () } ; (@ select_field_to_selection ; name) => { :: prisma_client_rust :: Selection :: builder ("Name") . build () } ; (@ select_field_to_selection ; api_key) => { :: prisma_client_rust :: Selection :: builder ("ApiKey") . build () } ; (@ select_field_to_selection ; activity $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? { $ ($ selections : tt) + }) => { { # [allow (warnings)] let mut selection = :: prisma_client_rust :: Selection :: builder ("Activity") ; $ (let args = $ crate :: prisma :: activity :: ManyArgs :: new ($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) * ; selection . set_arguments (args . to_graphql () . 0) ;) ? selection . nested_selections ($ crate :: prisma :: activity :: select ! (@ select_fields_to_selections ; $ ($ selections) +)) ; selection . build () } } ; (@ select_field_to_selection ; activity $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { # [allow (warnings)] let mut selection = :: prisma_client_rust :: Selection :: builder ("Activity") ; $ (let args = $ crate :: prisma :: activity :: ManyArgs :: new ($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) * ; selection . set_arguments (args . to_graphql () . 0) ;) ? selection . nested_selections ($ crate :: prisma :: activity :: _outputs ()) ; selection . build () } } ; (@ select_field_to_selection ; $ ($ tokens : tt) *) => { :: prisma_client_rust :: Selection :: builder ("") . build () } ; }
    pub use _select_user as select;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "ID")]
        pub id: String,
        #[serde(rename = "Name")]
        pub name: String,
        #[serde(rename = "ApiKey")]
        pub api_key: String,
        #[serde(rename = "Activity")]
        pub activity: Option<Vec<super::activity::Data>>,
    }
    impl Data {
        pub fn activity(&self) -> Result<&Vec<super::activity::Data>, &'static str> {
            self.activity.as_ref().ok_or(
                "Attempted to acccess 'activity' but did not fetch it using the .with() syntax",
            )
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Activity(super::activity::ManyArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Activity(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(super::activity::_outputs());
                    let mut builder = ::prisma_client_rust::Selection::builder("Activity");
                    builder
                        .nested_selections(nested_selections)
                        .set_arguments(arguments);
                    builder.build()
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(String),
        SetName(String),
        SetApiKey(String),
        ConnectActivity(Vec<super::activity::UniqueWhereParam>),
        DisconnectActivity(Vec<super::activity::UniqueWhereParam>),
        SetActivity(Vec<super::activity::UniqueWhereParam>),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                SetParam::SetId(value) => ("ID".to_string(), PrismaValue::String(value)),
                SetParam::SetName(value) => ("Name".to_string(), PrismaValue::String(value)),
                SetParam::SetApiKey(value) => ("ApiKey".to_string(), PrismaValue::String(value)),
                SetParam::ConnectActivity(where_params) => (
                    "Activity".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::activity::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectActivity(where_params) => (
                    "Activity".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::activity::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetActivity(where_params) => (
                    "Activity".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::activity::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(Direction),
        Name(Direction),
        ApiKey(Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    "ID".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Name(direction) => (
                    "Name".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::ApiKey(direction) => (
                    "ApiKey".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum Cursor {
        Id(String),
        Name(String),
        ApiKey(String),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for Cursor {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(cursor) => ("ID".to_string(), PrismaValue::String(cursor)),
                Self::Name(cursor) => ("Name".to_string(), PrismaValue::String(cursor)),
                Self::ApiKey(cursor) => ("ApiKey".to_string(), PrismaValue::String(cursor)),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        IdEquals(String),
        IdInVec(Vec<String>),
        IdNotInVec(Vec<String>),
        IdLt(String),
        IdLte(String),
        IdGt(String),
        IdGte(String),
        IdContains(String),
        IdStartsWith(String),
        IdEndsWith(String),
        IdMode(QueryMode),
        IdNot(String),
        NameEquals(String),
        NameInVec(Vec<String>),
        NameNotInVec(Vec<String>),
        NameLt(String),
        NameLte(String),
        NameGt(String),
        NameGte(String),
        NameContains(String),
        NameStartsWith(String),
        NameEndsWith(String),
        NameMode(QueryMode),
        NameNot(String),
        ApiKeyEquals(String),
        ApiKeyInVec(Vec<String>),
        ApiKeyNotInVec(Vec<String>),
        ApiKeyLt(String),
        ApiKeyLte(String),
        ApiKeyGt(String),
        ApiKeyGte(String),
        ApiKeyContains(String),
        ApiKeyStartsWith(String),
        ApiKeyEndsWith(String),
        ApiKeyMode(QueryMode),
        ApiKeyNot(String),
        ActivitySome(Vec<super::activity::WhereParam>),
        ActivityEvery(Vec<super::activity::WhereParam>),
        ActivityNone(Vec<super::activity::WhereParam>),
    }
    impl Into<::prisma_client_rust::SerializedWhere> for WhereParam {
        fn into(self) -> ::prisma_client_rust::SerializedWhere {
            match self {
                Self::Not(value) => ::prisma_client_rust::SerializedWhere::new(
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        value
                            .into_iter()
                            .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                            .map(Into::into)
                            .collect(),
                    ),
                ),
                Self::Or(value) => ::prisma_client_rust::SerializedWhere::new(
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => ::prisma_client_rust::SerializedWhere::new(
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        value
                            .into_iter()
                            .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                            .map(Into::into)
                            .collect(),
                    ),
                ),
                Self::IdEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ID",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ID",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::IdNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ID",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::IdLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ID",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ID",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ID",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ID",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdContains(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ID",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdStartsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ID",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdEndsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ID",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdMode(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ID",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::IdNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ID",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::NameEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "Name",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::NameInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "Name",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::NameNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "Name",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::NameLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "Name",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::NameLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "Name",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::NameGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "Name",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::NameGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "Name",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::NameContains(value) => ::prisma_client_rust::SerializedWhere::new(
                    "Name",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::NameStartsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "Name",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::NameEndsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "Name",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::NameMode(value) => ::prisma_client_rust::SerializedWhere::new(
                    "Name",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::NameNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "Name",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ApiKeyEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ApiKey",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ApiKeyInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ApiKey",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::ApiKeyNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ApiKey",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::ApiKeyLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ApiKey",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ApiKeyLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ApiKey",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ApiKeyGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ApiKey",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ApiKeyGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ApiKey",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ApiKeyContains(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ApiKey",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ApiKeyStartsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ApiKey",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ApiKeyEndsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ApiKey",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ApiKeyMode(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ApiKey",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::ApiKeyNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ApiKey",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ActivitySome(where_params) => ::prisma_client_rust::SerializedWhere::new(
                    "Activity",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ActivityEvery(where_params) => ::prisma_client_rust::SerializedWhere::new(
                    "Activity",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ActivityNone(where_params) => ::prisma_client_rust::SerializedWhere::new(
                    "Activity",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        NameEquals(String),
        ApiKeyEquals(String),
        IdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::NameEquals(value) => Self::NameEquals(value),
                UniqueWhereParam::ApiKeyEquals(value) => Self::ApiKeyEquals(value),
                UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
            }
        }
    }
    impl From<Operator<Self>> for WhereParam {
        fn from(op: Operator<Self>) -> Self {
            match op {
                Operator::Not(value) => Self::Not(value),
                Operator::And(value) => Self::And(value),
                Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<WithParam>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<WhereParam, WithParam, OrderByParam, Cursor>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, WhereParam, OrderByParam, Cursor>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, SetParam, WithParam, Data>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, SetParam>;
    pub type FindUnique<'a> =
        ::prisma_client_rust::FindUnique<'a, WhereParam, WithParam, SetParam, Data>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<
        'a,
        WhereParam,
        WithParam,
        OrderByParam,
        Cursor,
        SetParam,
        Data,
    >;
    pub type FindFirst<'a> =
        ::prisma_client_rust::FindFirst<'a, WhereParam, WithParam, OrderByParam, Cursor, Data>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, WhereParam, WithParam, SetParam, Data>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, WhereParam, SetParam>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, WhereParam, SetParam, WithParam, Data>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, WhereParam, WithParam, Data>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, WhereParam>;
    pub struct Actions<'a> {
        pub client: &'a PrismaClient,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("User", _outputs()),
                _where.into(),
            )
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("User", _outputs()),
                _where,
            )
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("User", _outputs()),
                _where,
            )
        }
        pub fn create(
            self,
            id: String,
            name: String,
            api_key: String,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.push(id::set(id));
            _params.push(name::set(name));
            _params.push(api_key::set(api_key));
            Create::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("User", _outputs()),
                _params,
            )
        }
        pub fn create_many(
            self,
            data: Vec<(String, String, String, Vec<SetParam>)>,
        ) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(id, name, api_key, mut _params)| {
                    _params.push(id::set(id));
                    _params.push(name::set(name));
                    _params.push(api_key::set(api_key));
                    _params
                })
                .collect();
            CreateMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("User", _outputs()),
                data,
            )
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("User", _outputs()),
                _where.into(),
                _params,
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("User", _outputs()),
                _where,
                _params,
            )
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (id, name, api_key, mut _params): (String, String, String, Vec<SetParam>),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.push(id::set(id));
            _params.push(name::set(name));
            _params.push(api_key::set(api_key));
            Upsert::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("User", _outputs()),
                _where.into(),
                _params,
                _update,
            )
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("User", _outputs()),
                _where.into(),
                vec![],
            )
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("User", _outputs()),
                _where.into(),
            )
        }
        pub fn count(self) -> Count<'a> {
            Count::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("User", _outputs()),
                vec![],
            )
        }
    }
}
pub mod _prisma {
    pub struct PrismaClient {
        executor: Box<dyn ::prisma_client_rust::query_core::QueryExecutor + Send + Sync + 'static>,
        query_schema: ::std::sync::Arc<::prisma_client_rust::schema::QuerySchema>,
    }
    impl ::std::fmt::Debug for PrismaClient {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.debug_struct("PrismaClient").finish()
        }
    }
    impl PrismaClient {
        pub(super) fn _new_query_context(&self) -> ::prisma_client_rust::queries::QueryContext {
            ::prisma_client_rust::queries::QueryContext::new(
                &self.executor,
                self.query_schema.clone(),
            )
        }
        pub(super) fn _new(
            executor: Box<
                dyn ::prisma_client_rust::query_core::QueryExecutor + Send + Sync + 'static,
            >,
            query_schema: std::sync::Arc<::prisma_client_rust::schema::QuerySchema>,
        ) -> Self {
            Self {
                executor,
                query_schema,
            }
        }
        pub fn _query_raw<T: serde::de::DeserializeOwned>(
            &self,
            query: ::prisma_client_rust::raw::Raw,
        ) -> ::prisma_client_rust::QueryRaw<T> {
            ::prisma_client_rust::QueryRaw::new(
                ::prisma_client_rust::queries::QueryContext::new(
                    &self.executor,
                    self.query_schema.clone(),
                ),
                query,
                super::DATABASE_STR,
            )
        }
        pub fn _execute_raw(
            &self,
            query: ::prisma_client_rust::raw::Raw,
        ) -> ::prisma_client_rust::ExecuteRaw {
            ::prisma_client_rust::ExecuteRaw::new(
                ::prisma_client_rust::queries::QueryContext::new(
                    &self.executor,
                    self.query_schema.clone(),
                ),
                query,
                super::DATABASE_STR,
            )
        }
        pub async fn _batch<T: ::prisma_client_rust::BatchContainer<Marker>, Marker>(
            &self,
            queries: T,
        ) -> ::prisma_client_rust::queries::Result<T::ReturnType> {
            ::prisma_client_rust::batch(queries, &self.executor, &self.query_schema).await
        }
        pub fn activity(&self) -> super::activity::Actions {
            super::activity::Actions { client: &self }
        }
        pub fn device(&self) -> super::device::Actions {
            super::device::Actions { client: &self }
        }
        pub fn device_activity(&self) -> super::device_activity::Actions {
            super::device_activity::Actions { client: &self }
        }
        pub fn user(&self) -> super::user::Actions {
            super::user::Actions { client: &self }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum ActivityScalarFieldEnum {
        #[serde(rename = "ID")]
        Id,
        #[serde(rename = "UpdatedAt")]
        UpdatedAt,
        #[serde(rename = "CreatedAt")]
        CreatedAt,
        #[serde(rename = "Name")]
        Name,
        #[serde(rename = "UserId")]
        UserId,
    }
    impl ToString for ActivityScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "ID".to_string(),
                Self::UpdatedAt => "UpdatedAt".to_string(),
                Self::CreatedAt => "CreatedAt".to_string(),
                Self::Name => "Name".to_string(),
                Self::UserId => "UserId".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum DeviceActivityScalarFieldEnum {
        #[serde(rename = "ID")]
        Id,
        #[serde(rename = "UpdatedAt")]
        UpdatedAt,
        #[serde(rename = "CreatedAt")]
        CreatedAt,
        #[serde(rename = "ActivityId")]
        ActivityId,
        #[serde(rename = "DeviceId")]
        DeviceId,
    }
    impl ToString for DeviceActivityScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "ID".to_string(),
                Self::UpdatedAt => "UpdatedAt".to_string(),
                Self::CreatedAt => "CreatedAt".to_string(),
                Self::ActivityId => "ActivityId".to_string(),
                Self::DeviceId => "DeviceId".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum DeviceScalarFieldEnum {
        #[serde(rename = "ID")]
        Id,
        #[serde(rename = "Name")]
        Name,
    }
    impl ToString for DeviceScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "ID".to_string(),
                Self::Name => "Name".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum QueryMode {
        #[serde(rename = "default")]
        Default,
        #[serde(rename = "insensitive")]
        Insensitive,
    }
    impl ToString for QueryMode {
        fn to_string(&self) -> String {
            match self {
                Self::Default => "default".to_string(),
                Self::Insensitive => "insensitive".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum SortOrder {
        #[serde(rename = "asc")]
        Asc,
        #[serde(rename = "desc")]
        Desc,
    }
    impl ToString for SortOrder {
        fn to_string(&self) -> String {
            match self {
                Self::Asc => "asc".to_string(),
                Self::Desc => "desc".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum TransactionIsolationLevel {
        #[serde(rename = "ReadUncommitted")]
        ReadUncommitted,
        #[serde(rename = "ReadCommitted")]
        ReadCommitted,
        #[serde(rename = "RepeatableRead")]
        RepeatableRead,
        #[serde(rename = "Serializable")]
        Serializable,
    }
    impl ToString for TransactionIsolationLevel {
        fn to_string(&self) -> String {
            match self {
                Self::ReadUncommitted => "ReadUncommitted".to_string(),
                Self::ReadCommitted => "ReadCommitted".to_string(),
                Self::RepeatableRead => "RepeatableRead".to_string(),
                Self::Serializable => "Serializable".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum UserScalarFieldEnum {
        #[serde(rename = "ID")]
        Id,
        #[serde(rename = "Name")]
        Name,
        #[serde(rename = "ApiKey")]
        ApiKey,
    }
    impl ToString for UserScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "ID".to_string(),
                Self::Name => "Name".to_string(),
                Self::ApiKey => "ApiKey".to_string(),
            }
        }
    }
}
pub use _prisma::PrismaClient;
