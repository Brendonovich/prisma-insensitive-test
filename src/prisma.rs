// Code generated by Prisma Client Rust. DO NOT EDIT

#![allow(warnings, unused)]
use prisma_client_rust::{
    bigdecimal::{self, FromPrimitive},
    chrono,
    datamodel::parse_configuration,
    operator::Operator,
    prisma_models::{InternalDataModelBuilder, PrismaValue},
    queries::{QueryContext, QueryInfo, Result as QueryResult},
    query_core::{
        executor, schema_builder, BuildMode, CoreError, InterpreterError, QueryExecutor,
        QueryGraphBuilderError, QuerySchema, QueryValue, Selection,
    },
    serde_json, BatchResult, Direction, ManyArgs, SerializedWhere, SerializedWhereValue,
    UniqueArgs,
};
pub use prisma_client_rust::{queries::Error as QueryError, NewClientError};
use serde::{Deserialize, Serialize};
use std::path::Path;
use std::sync::Arc;
static DATAMODEL_STR : & 'static str = "generator client {\n    // Corresponds to the cargo alias created earlier\n    provider      = \"cargo prisma\"\n    // The location to generate the schema. Is relative to the position of the schema\n    output        = \"../src/prisma.rs\"\n}\n\ndatasource db {\n  provider = \"postgresql\"\n  url      = env(\"DATABASE_URL\")\n}\n\nmodel Activity {\n  ID             String           @id\n  UpdatedAt      DateTime         @default(now())\n  CreatedAt      DateTime         @default(now())\n  Name           String           @unique\n  UserId         String\n  User           User             @relation(fields: [UserId], references: [ID])\n  DeviceActivity DeviceActivity[]\n}\n\nmodel Device {\n  ID             String           @id\n  Name           String           @unique\n  DeviceActivity DeviceActivity[]\n}\n\nmodel DeviceActivity {\n  ID         String    @id\n  UpdatedAt  DateTime  @default(now())\n  CreatedAt  DateTime  @default(now())\n  ActivityId String?\n  DeviceId   String\n  Activity   Activity? @relation(fields: [ActivityId], references: [ID])\n  Device     Device    @relation(fields: [DeviceId], references: [ID])\n}\n\nmodel User {\n  ID       String     @id\n  Name     String     @unique\n  ApiKey   String     @unique\n  Activity Activity[]\n}\n" ;
static DATABASE_STR: &'static str = "postgresql";
pub async fn new_client() -> Result<_prisma::PrismaClient, NewClientError> {
    let config = parse_configuration(DATAMODEL_STR)?.subject;
    let source = config
        .datasources
        .first()
        .expect("Please supply a datasource in your schema.prisma file");
    let url = if let Some(url) = source.load_shadow_database_url()? {
        url
    } else {
        source.load_url(|key| std::env::var(key).ok())?
    };
    let url = if url.starts_with("file:") {
        let path = url.split(":").nth(1).unwrap();
        if Path::new("./schema.prisma").exists() {
            url
        } else if Path::new("./prisma/schema.prisma").exists() {
            format!("file:./prisma/{}", path)
        } else {
            url
        }
    } else {
        url
    };
    new_client_with_url(&url).await
}
pub async fn new_client_with_url(url: &str) -> Result<_prisma::PrismaClient, NewClientError> {
    let config = parse_configuration(DATAMODEL_STR)?.subject;
    let source = config
        .datasources
        .first()
        .expect("Please supply a datasource in your schema.prisma file");
    let (db_name, executor) = executor::load(&source, &[], &url).await?;
    let internal_model = InternalDataModelBuilder::new(DATAMODEL_STR).build(db_name);
    let query_schema = Arc::new(schema_builder::build(
        internal_model,
        BuildMode::Modern,
        true,
        source.capabilities(),
        vec![],
        source.referential_integrity(),
    ));
    executor.primary_connector().get_connection().await?;
    Ok(PrismaClient::_new(executor, query_schema))
}
pub mod activity {
    use super::_prisma::*;
    use super::*;
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn cursor(cursor: String) -> Cursor {
            Cursor::Id(cursor)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::IdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::IdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::IdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::IdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::IdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::IdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::IdEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::IdMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::IdNot(value)
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetId(value.0)
            }
        }
    }
    pub mod updated_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: chrono::DateTime<chrono::FixedOffset>) -> T {
            Set(value).into()
        }
        pub fn equals(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::UpdatedAt(direction)
        }
        pub fn in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::UpdatedAtInVec(value)
        }
        pub fn not_in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::UpdatedAtNotInVec(value)
        }
        pub fn lt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtLt(value)
        }
        pub fn lte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtLte(value)
        }
        pub fn gt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtGt(value)
        }
        pub fn gte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtGte(value)
        }
        pub fn not(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtNot(value)
        }
        pub struct Set(pub chrono::DateTime<chrono::FixedOffset>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetUpdatedAt(value.0)
            }
        }
    }
    pub mod created_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: chrono::DateTime<chrono::FixedOffset>) -> T {
            Set(value).into()
        }
        pub fn equals(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::CreatedAt(direction)
        }
        pub fn in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::CreatedAtInVec(value)
        }
        pub fn not_in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::CreatedAtNotInVec(value)
        }
        pub fn lt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtLt(value)
        }
        pub fn lte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtLte(value)
        }
        pub fn gt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtGt(value)
        }
        pub fn gte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtGte(value)
        }
        pub fn not(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtNot(value)
        }
        pub struct Set(pub chrono::DateTime<chrono::FixedOffset>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetCreatedAt(value.0)
            }
        }
    }
    pub mod name {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::NameEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Name(direction)
        }
        pub fn cursor(cursor: String) -> Cursor {
            Cursor::Name(cursor)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::NameInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::NameNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::NameLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::NameLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::NameGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::NameGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::NameContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::NameStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::NameEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::NameMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::NameNot(value)
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetName(value.0)
            }
        }
    }
    pub mod user_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::UserIdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::UserId(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::UserIdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::UserIdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::UserIdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::UserIdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::UserIdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::UserIdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::UserIdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::UserIdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::UserIdEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::UserIdMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::UserIdNot(value)
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetUserId(value.0)
            }
        }
    }
    pub mod user {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn is(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::UserIs(value)
        }
        pub fn is_not(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::UserIsNot(value)
        }
        pub struct Fetch(pub user::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<user::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::User(fetch.0)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(user::UniqueArgs::new())
        }
        pub fn link<T: From<Link>>(value: user::UniqueWhereParam) -> T {
            Link(value).into()
        }
        pub struct Link(user::UniqueWhereParam);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkUser(value.0)
            }
        }
    }
    pub mod device_activity {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn some(value: Vec<device_activity::WhereParam>) -> WhereParam {
            WhereParam::DeviceActivitySome(value)
        }
        pub fn every(value: Vec<device_activity::WhereParam>) -> WhereParam {
            WhereParam::DeviceActivityEvery(value)
        }
        pub fn none(value: Vec<device_activity::WhereParam>) -> WhereParam {
            WhereParam::DeviceActivityNone(value)
        }
        pub struct Fetch(pub device_activity::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<device_activity::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: device_activity::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: impl Into<device_activity::Cursor>) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::DeviceActivity(fetch.0)
            }
        }
        pub fn fetch(params: Vec<device_activity::WhereParam>) -> Fetch {
            Fetch(device_activity::ManyArgs::new(params))
        }
        pub fn link<T: From<Link>>(params: Vec<device_activity::UniqueWhereParam>) -> T {
            Link(params).into()
        }
        pub fn unlink(params: Vec<device_activity::UniqueWhereParam>) -> SetParam {
            SetParam::UnlinkDeviceActivity(params)
        }
        pub struct Link(pub Vec<device_activity::UniqueWhereParam>);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkDeviceActivity(value.0)
            }
        }
    }
    pub fn _outputs() -> Vec<Selection> {
        ["ID", "UpdatedAt", "CreatedAt", "Name", "UserId"]
            .into_iter()
            .map(|o| {
                let builder = Selection::builder(o);
                builder.build()
            })
            .collect()
    }
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct Data {
        #[serde(rename = "ID")]
        pub id: String,
        #[serde(rename = "UpdatedAt")]
        pub updated_at: chrono::DateTime<chrono::FixedOffset>,
        #[serde(rename = "CreatedAt")]
        pub created_at: chrono::DateTime<chrono::FixedOffset>,
        #[serde(rename = "Name")]
        pub name: String,
        #[serde(rename = "UserId")]
        pub user_id: String,
        #[serde(rename = "User")]
        pub user: Option<Box<super::user::Data>>,
        #[serde(rename = "DeviceActivity")]
        pub device_activity: Option<Vec<super::device_activity::Data>>,
    }
    impl Data {
        pub fn user(&self) -> Result<&super::user::Data, &'static str> {
            self.user
                .as_ref()
                .ok_or("Attempted to access 'user' but did not fetch it using the .with() syntax")
                .map(|v| v.as_ref())
        }
        pub fn device_activity(&self) -> Result<&Vec<super::device_activity::Data>, &'static str> {
            self . device_activity . as_ref () . ok_or ("Attempted to access 'device_activity' but did not fetch it using the .with() syntax")
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        User(super::user::UniqueArgs),
        DeviceActivity(super::device_activity::ManyArgs),
    }
    impl Into<Selection> for WithParam {
        fn into(self) -> Selection {
            match self {
                Self::User(args) => {
                    let mut selections = super::user::_outputs();
                    selections.extend(args.with_params.into_iter().map(Into::<Selection>::into));
                    let mut builder = Selection::builder("User");
                    builder.nested_selections(selections);
                    builder.build()
                }
                Self::DeviceActivity(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(super::device_activity::_outputs());
                    let mut builder = Selection::builder("DeviceActivity");
                    builder
                        .nested_selections(nested_selections)
                        .set_arguments(arguments);
                    builder.build()
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(String),
        SetUpdatedAt(chrono::DateTime<chrono::FixedOffset>),
        SetCreatedAt(chrono::DateTime<chrono::FixedOffset>),
        SetName(String),
        SetUserId(String),
        LinkUser(super::user::UniqueWhereParam),
        LinkDeviceActivity(Vec<super::device_activity::UniqueWhereParam>),
        UnlinkDeviceActivity(Vec<super::device_activity::UniqueWhereParam>),
    }
    impl Into<(String, PrismaValue)> for SetParam {
        fn into(self) -> (String, PrismaValue) {
            match self {
                SetParam::SetId(value) => ("ID".to_string(), PrismaValue::String(value)),
                SetParam::SetUpdatedAt(value) => {
                    ("UpdatedAt".to_string(), PrismaValue::DateTime(value))
                }
                SetParam::SetCreatedAt(value) => {
                    ("CreatedAt".to_string(), PrismaValue::DateTime(value))
                }
                SetParam::SetName(value) => ("Name".to_string(), PrismaValue::String(value)),
                SetParam::SetUserId(value) => ("UserId".to_string(), PrismaValue::String(value)),
                SetParam::LinkUser(where_param) => (
                    "User".to_string(),
                    PrismaValue::Object(vec![(
                        "connect".to_string(),
                        PrismaValue::Object(
                            vec![where_param]
                                .into_iter()
                                .map(Into::<super::user::WhereParam>::into)
                                .map(Into::<SerializedWhere>::into)
                                .map(SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::LinkDeviceActivity(where_params) => (
                    "DeviceActivity".to_string(),
                    PrismaValue::Object(vec![(
                        "connect".to_string(),
                        PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<super::device_activity::WhereParam>::into)
                                .map(Into::<SerializedWhere>::into)
                                .map(SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::UnlinkDeviceActivity(where_params) => (
                    "DeviceActivity".to_string(),
                    PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<super::device_activity::WhereParam>::into)
                                .map(Into::<SerializedWhere>::into)
                                .map(SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(Direction),
        UpdatedAt(Direction),
        CreatedAt(Direction),
        Name(Direction),
        UserId(Direction),
    }
    impl Into<(String, PrismaValue)> for OrderByParam {
        fn into(self) -> (String, PrismaValue) {
            match self {
                Self::Id(direction) => {
                    ("ID".to_string(), PrismaValue::String(direction.to_string()))
                }
                Self::UpdatedAt(direction) => (
                    "UpdatedAt".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::CreatedAt(direction) => (
                    "CreatedAt".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::Name(direction) => (
                    "Name".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::UserId(direction) => (
                    "UserId".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum Cursor {
        Id(String),
        Name(String),
    }
    impl Into<(String, PrismaValue)> for Cursor {
        fn into(self) -> (String, PrismaValue) {
            match self {
                Self::Id(cursor) => ("ID".to_string(), PrismaValue::String(cursor)),
                Self::Name(cursor) => ("Name".to_string(), PrismaValue::String(cursor)),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        IdEquals(String),
        IdInVec(Vec<String>),
        IdNotInVec(Vec<String>),
        IdLt(String),
        IdLte(String),
        IdGt(String),
        IdGte(String),
        IdContains(String),
        IdStartsWith(String),
        IdEndsWith(String),
        IdMode(QueryMode),
        IdNot(String),
        UpdatedAtEquals(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        UpdatedAtNotInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        UpdatedAtLt(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtLte(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtGt(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtGte(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtNot(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtEquals(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        CreatedAtNotInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        CreatedAtLt(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtLte(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtGt(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtGte(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtNot(chrono::DateTime<chrono::FixedOffset>),
        NameEquals(String),
        NameInVec(Vec<String>),
        NameNotInVec(Vec<String>),
        NameLt(String),
        NameLte(String),
        NameGt(String),
        NameGte(String),
        NameContains(String),
        NameStartsWith(String),
        NameEndsWith(String),
        NameMode(QueryMode),
        NameNot(String),
        UserIdEquals(String),
        UserIdInVec(Vec<String>),
        UserIdNotInVec(Vec<String>),
        UserIdLt(String),
        UserIdLte(String),
        UserIdGt(String),
        UserIdGte(String),
        UserIdContains(String),
        UserIdStartsWith(String),
        UserIdEndsWith(String),
        UserIdMode(QueryMode),
        UserIdNot(String),
        UserIs(Vec<super::user::WhereParam>),
        UserIsNot(Vec<super::user::WhereParam>),
        DeviceActivitySome(Vec<super::device_activity::WhereParam>),
        DeviceActivityEvery(Vec<super::device_activity::WhereParam>),
        DeviceActivityNone(Vec<super::device_activity::WhereParam>),
    }
    impl Into<SerializedWhere> for WhereParam {
        fn into(self) -> SerializedWhere {
            match self {
                Self::Not(value) => SerializedWhere::new(
                    "NOT",
                    SerializedWhereValue::Object(
                        value
                            .into_iter()
                            .map(Into::<SerializedWhere>::into)
                            .map(Into::into)
                            .collect(),
                    ),
                ),
                Self::Or(value) => SerializedWhere::new(
                    "OR",
                    SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(Into::<SerializedWhere>::into)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => SerializedWhere::new(
                    "AND",
                    SerializedWhereValue::Object(
                        value
                            .into_iter()
                            .map(Into::<SerializedWhere>::into)
                            .map(Into::into)
                            .collect(),
                    ),
                ),
                Self::IdEquals(value) => SerializedWhere::new(
                    "ID",
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdInVec(value) => SerializedWhere::new(
                    "ID",
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::IdNotInVec(value) => SerializedWhere::new(
                    "ID",
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::IdLt(value) => SerializedWhere::new(
                    "ID",
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdLte(value) => SerializedWhere::new(
                    "ID",
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdGt(value) => SerializedWhere::new(
                    "ID",
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdGte(value) => SerializedWhere::new(
                    "ID",
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdContains(value) => SerializedWhere::new(
                    "ID",
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdStartsWith(value) => SerializedWhere::new(
                    "ID",
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdEndsWith(value) => SerializedWhere::new(
                    "ID",
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdMode(value) => SerializedWhere::new(
                    "ID",
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::IdNot(value) => SerializedWhere::new(
                    "ID",
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UpdatedAtEquals(value) => SerializedWhere::new(
                    "UpdatedAt",
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtInVec(value) => SerializedWhere::new(
                    "UpdatedAt",
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::UpdatedAtNotInVec(value) => SerializedWhere::new(
                    "UpdatedAt",
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::UpdatedAtLt(value) => SerializedWhere::new(
                    "UpdatedAt",
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtLte(value) => SerializedWhere::new(
                    "UpdatedAt",
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtGt(value) => SerializedWhere::new(
                    "UpdatedAt",
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtGte(value) => SerializedWhere::new(
                    "UpdatedAt",
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtNot(value) => SerializedWhere::new(
                    "UpdatedAt",
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtEquals(value) => SerializedWhere::new(
                    "CreatedAt",
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtInVec(value) => SerializedWhere::new(
                    "CreatedAt",
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::CreatedAtNotInVec(value) => SerializedWhere::new(
                    "CreatedAt",
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::CreatedAtLt(value) => SerializedWhere::new(
                    "CreatedAt",
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtLte(value) => SerializedWhere::new(
                    "CreatedAt",
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtGt(value) => SerializedWhere::new(
                    "CreatedAt",
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtGte(value) => SerializedWhere::new(
                    "CreatedAt",
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtNot(value) => SerializedWhere::new(
                    "CreatedAt",
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::NameEquals(value) => SerializedWhere::new(
                    "Name",
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::NameInVec(value) => SerializedWhere::new(
                    "Name",
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::NameNotInVec(value) => SerializedWhere::new(
                    "Name",
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::NameLt(value) => SerializedWhere::new(
                    "Name",
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::NameLte(value) => SerializedWhere::new(
                    "Name",
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::NameGt(value) => SerializedWhere::new(
                    "Name",
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::NameGte(value) => SerializedWhere::new(
                    "Name",
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::NameContains(value) => SerializedWhere::new(
                    "Name",
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::NameStartsWith(value) => SerializedWhere::new(
                    "Name",
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::NameEndsWith(value) => SerializedWhere::new(
                    "Name",
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::NameMode(value) => SerializedWhere::new(
                    "Name",
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::NameNot(value) => SerializedWhere::new(
                    "Name",
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdEquals(value) => SerializedWhere::new(
                    "UserId",
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdInVec(value) => SerializedWhere::new(
                    "UserId",
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::UserIdNotInVec(value) => SerializedWhere::new(
                    "UserId",
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::UserIdLt(value) => SerializedWhere::new(
                    "UserId",
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdLte(value) => SerializedWhere::new(
                    "UserId",
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdGt(value) => SerializedWhere::new(
                    "UserId",
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdGte(value) => SerializedWhere::new(
                    "UserId",
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdContains(value) => SerializedWhere::new(
                    "UserId",
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdStartsWith(value) => SerializedWhere::new(
                    "UserId",
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdEndsWith(value) => SerializedWhere::new(
                    "UserId",
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdMode(value) => SerializedWhere::new(
                    "UserId",
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::UserIdNot(value) => SerializedWhere::new(
                    "UserId",
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIs(where_params) => SerializedWhere::new(
                    "User",
                    SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<SerializedWhere>::into)
                                .map(SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::UserIsNot(where_params) => SerializedWhere::new(
                    "User",
                    SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<SerializedWhere>::into)
                                .map(SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::DeviceActivitySome(where_params) => SerializedWhere::new(
                    "DeviceActivity",
                    SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<SerializedWhere>::into)
                                .map(SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::DeviceActivityEvery(where_params) => SerializedWhere::new(
                    "DeviceActivity",
                    SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<SerializedWhere>::into)
                                .map(SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::DeviceActivityNone(where_params) => SerializedWhere::new(
                    "DeviceActivity",
                    SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<SerializedWhere>::into)
                                .map(SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        NameEquals(String),
        IdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::NameEquals(value) => Self::NameEquals(value),
                UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
            }
        }
    }
    impl From<Operator<Self>> for WhereParam {
        fn from(op: Operator<Self>) -> Self {
            match op {
                Operator::Not(value) => Self::Not(value),
                Operator::And(value) => Self::And(value),
                Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type UniqueArgs = prisma_client_rust::UniqueArgs<WithParam>;
    pub type ManyArgs = prisma_client_rust::ManyArgs<WhereParam, WithParam, OrderByParam, Cursor>;
    pub type Count<'a> = prisma_client_rust::Count<'a, WhereParam, OrderByParam, Cursor>;
    pub type Create<'a> = prisma_client_rust::Create<'a, SetParam, WithParam, Data>;
    pub type FindUnique<'a> =
        prisma_client_rust::FindUnique<'a, WhereParam, WithParam, SetParam, Data>;
    pub type FindMany<'a> = prisma_client_rust::FindMany<
        'a,
        WhereParam,
        WithParam,
        OrderByParam,
        Cursor,
        SetParam,
        Data,
    >;
    pub type FindFirst<'a> =
        prisma_client_rust::FindFirst<'a, WhereParam, WithParam, OrderByParam, Cursor, Data>;
    pub type Update<'a> = prisma_client_rust::Update<'a, WhereParam, WithParam, SetParam, Data>;
    pub type UpdateMany<'a> = prisma_client_rust::UpdateMany<'a, WhereParam, SetParam>;
    pub type Upsert<'a> = prisma_client_rust::Upsert<'a, WhereParam, SetParam, WithParam, Data>;
    pub type Delete<'a> = prisma_client_rust::Delete<'a, WhereParam, WithParam, Data>;
    pub type DeleteMany<'a> = prisma_client_rust::DeleteMany<'a, WhereParam>;
    pub struct Actions<'a> {
        pub client: &'a PrismaClient,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(
                self.client._new_query_context(),
                QueryInfo::new("Activity", _outputs()),
                _where.into(),
            )
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(
                self.client._new_query_context(),
                QueryInfo::new("Activity", _outputs()),
                _where,
            )
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(
                self.client._new_query_context(),
                QueryInfo::new("Activity", _outputs()),
                _where,
            )
        }
        pub fn create(
            self,
            id: String,
            name: String,
            user: super::user::UniqueWhereParam,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.push(id::set(id));
            _params.push(name::set(name));
            _params.push(user::link(user));
            Create::new(
                self.client._new_query_context(),
                QueryInfo::new("Activity", _outputs()),
                _params,
            )
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(
                self.client._new_query_context(),
                QueryInfo::new("Activity", _outputs()),
                _where.into(),
                _params,
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(
                self.client._new_query_context(),
                QueryInfo::new("Activity", _outputs()),
                _where,
                _params,
            )
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(
                self.client._new_query_context(),
                QueryInfo::new("Activity", _outputs()),
                _where.into(),
                vec![],
            )
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(
                self.client._new_query_context(),
                QueryInfo::new("Activity", _outputs()),
                _where.into(),
            )
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (id, name, user, mut _params): (
                String,
                String,
                super::user::UniqueWhereParam,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.push(id::set(id));
            _params.push(name::set(name));
            _params.push(user::link(user));
            Upsert::new(
                self.client._new_query_context(),
                QueryInfo::new("Activity", _outputs()),
                _where.into(),
                _params,
                _update,
            )
        }
        pub fn count(self) -> Count<'a> {
            Count::new(
                self.client._new_query_context(),
                QueryInfo::new("Activity", _outputs()),
                vec![],
            )
        }
    }
}
pub mod device {
    use super::_prisma::*;
    use super::*;
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn cursor(cursor: String) -> Cursor {
            Cursor::Id(cursor)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::IdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::IdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::IdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::IdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::IdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::IdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::IdEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::IdMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::IdNot(value)
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetId(value.0)
            }
        }
    }
    pub mod name {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::NameEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Name(direction)
        }
        pub fn cursor(cursor: String) -> Cursor {
            Cursor::Name(cursor)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::NameInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::NameNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::NameLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::NameLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::NameGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::NameGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::NameContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::NameStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::NameEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::NameMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::NameNot(value)
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetName(value.0)
            }
        }
    }
    pub mod device_activity {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn some(value: Vec<device_activity::WhereParam>) -> WhereParam {
            WhereParam::DeviceActivitySome(value)
        }
        pub fn every(value: Vec<device_activity::WhereParam>) -> WhereParam {
            WhereParam::DeviceActivityEvery(value)
        }
        pub fn none(value: Vec<device_activity::WhereParam>) -> WhereParam {
            WhereParam::DeviceActivityNone(value)
        }
        pub struct Fetch(pub device_activity::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<device_activity::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: device_activity::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: impl Into<device_activity::Cursor>) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::DeviceActivity(fetch.0)
            }
        }
        pub fn fetch(params: Vec<device_activity::WhereParam>) -> Fetch {
            Fetch(device_activity::ManyArgs::new(params))
        }
        pub fn link<T: From<Link>>(params: Vec<device_activity::UniqueWhereParam>) -> T {
            Link(params).into()
        }
        pub fn unlink(params: Vec<device_activity::UniqueWhereParam>) -> SetParam {
            SetParam::UnlinkDeviceActivity(params)
        }
        pub struct Link(pub Vec<device_activity::UniqueWhereParam>);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkDeviceActivity(value.0)
            }
        }
    }
    pub fn _outputs() -> Vec<Selection> {
        ["ID", "Name"]
            .into_iter()
            .map(|o| {
                let builder = Selection::builder(o);
                builder.build()
            })
            .collect()
    }
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct Data {
        #[serde(rename = "ID")]
        pub id: String,
        #[serde(rename = "Name")]
        pub name: String,
        #[serde(rename = "DeviceActivity")]
        pub device_activity: Option<Vec<super::device_activity::Data>>,
    }
    impl Data {
        pub fn device_activity(&self) -> Result<&Vec<super::device_activity::Data>, &'static str> {
            self . device_activity . as_ref () . ok_or ("Attempted to access 'device_activity' but did not fetch it using the .with() syntax")
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        DeviceActivity(super::device_activity::ManyArgs),
    }
    impl Into<Selection> for WithParam {
        fn into(self) -> Selection {
            match self {
                Self::DeviceActivity(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(super::device_activity::_outputs());
                    let mut builder = Selection::builder("DeviceActivity");
                    builder
                        .nested_selections(nested_selections)
                        .set_arguments(arguments);
                    builder.build()
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(String),
        SetName(String),
        LinkDeviceActivity(Vec<super::device_activity::UniqueWhereParam>),
        UnlinkDeviceActivity(Vec<super::device_activity::UniqueWhereParam>),
    }
    impl Into<(String, PrismaValue)> for SetParam {
        fn into(self) -> (String, PrismaValue) {
            match self {
                SetParam::SetId(value) => ("ID".to_string(), PrismaValue::String(value)),
                SetParam::SetName(value) => ("Name".to_string(), PrismaValue::String(value)),
                SetParam::LinkDeviceActivity(where_params) => (
                    "DeviceActivity".to_string(),
                    PrismaValue::Object(vec![(
                        "connect".to_string(),
                        PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<super::device_activity::WhereParam>::into)
                                .map(Into::<SerializedWhere>::into)
                                .map(SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::UnlinkDeviceActivity(where_params) => (
                    "DeviceActivity".to_string(),
                    PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<super::device_activity::WhereParam>::into)
                                .map(Into::<SerializedWhere>::into)
                                .map(SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(Direction),
        Name(Direction),
    }
    impl Into<(String, PrismaValue)> for OrderByParam {
        fn into(self) -> (String, PrismaValue) {
            match self {
                Self::Id(direction) => {
                    ("ID".to_string(), PrismaValue::String(direction.to_string()))
                }
                Self::Name(direction) => (
                    "Name".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum Cursor {
        Id(String),
        Name(String),
    }
    impl Into<(String, PrismaValue)> for Cursor {
        fn into(self) -> (String, PrismaValue) {
            match self {
                Self::Id(cursor) => ("ID".to_string(), PrismaValue::String(cursor)),
                Self::Name(cursor) => ("Name".to_string(), PrismaValue::String(cursor)),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        IdEquals(String),
        IdInVec(Vec<String>),
        IdNotInVec(Vec<String>),
        IdLt(String),
        IdLte(String),
        IdGt(String),
        IdGte(String),
        IdContains(String),
        IdStartsWith(String),
        IdEndsWith(String),
        IdMode(QueryMode),
        IdNot(String),
        NameEquals(String),
        NameInVec(Vec<String>),
        NameNotInVec(Vec<String>),
        NameLt(String),
        NameLte(String),
        NameGt(String),
        NameGte(String),
        NameContains(String),
        NameStartsWith(String),
        NameEndsWith(String),
        NameMode(QueryMode),
        NameNot(String),
        DeviceActivitySome(Vec<super::device_activity::WhereParam>),
        DeviceActivityEvery(Vec<super::device_activity::WhereParam>),
        DeviceActivityNone(Vec<super::device_activity::WhereParam>),
    }
    impl Into<SerializedWhere> for WhereParam {
        fn into(self) -> SerializedWhere {
            match self {
                Self::Not(value) => SerializedWhere::new(
                    "NOT",
                    SerializedWhereValue::Object(
                        value
                            .into_iter()
                            .map(Into::<SerializedWhere>::into)
                            .map(Into::into)
                            .collect(),
                    ),
                ),
                Self::Or(value) => SerializedWhere::new(
                    "OR",
                    SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(Into::<SerializedWhere>::into)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => SerializedWhere::new(
                    "AND",
                    SerializedWhereValue::Object(
                        value
                            .into_iter()
                            .map(Into::<SerializedWhere>::into)
                            .map(Into::into)
                            .collect(),
                    ),
                ),
                Self::IdEquals(value) => SerializedWhere::new(
                    "ID",
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdInVec(value) => SerializedWhere::new(
                    "ID",
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::IdNotInVec(value) => SerializedWhere::new(
                    "ID",
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::IdLt(value) => SerializedWhere::new(
                    "ID",
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdLte(value) => SerializedWhere::new(
                    "ID",
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdGt(value) => SerializedWhere::new(
                    "ID",
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdGte(value) => SerializedWhere::new(
                    "ID",
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdContains(value) => SerializedWhere::new(
                    "ID",
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdStartsWith(value) => SerializedWhere::new(
                    "ID",
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdEndsWith(value) => SerializedWhere::new(
                    "ID",
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdMode(value) => SerializedWhere::new(
                    "ID",
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::IdNot(value) => SerializedWhere::new(
                    "ID",
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::NameEquals(value) => SerializedWhere::new(
                    "Name",
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::NameInVec(value) => SerializedWhere::new(
                    "Name",
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::NameNotInVec(value) => SerializedWhere::new(
                    "Name",
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::NameLt(value) => SerializedWhere::new(
                    "Name",
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::NameLte(value) => SerializedWhere::new(
                    "Name",
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::NameGt(value) => SerializedWhere::new(
                    "Name",
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::NameGte(value) => SerializedWhere::new(
                    "Name",
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::NameContains(value) => SerializedWhere::new(
                    "Name",
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::NameStartsWith(value) => SerializedWhere::new(
                    "Name",
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::NameEndsWith(value) => SerializedWhere::new(
                    "Name",
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::NameMode(value) => SerializedWhere::new(
                    "Name",
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::NameNot(value) => SerializedWhere::new(
                    "Name",
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::DeviceActivitySome(where_params) => SerializedWhere::new(
                    "DeviceActivity",
                    SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<SerializedWhere>::into)
                                .map(SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::DeviceActivityEvery(where_params) => SerializedWhere::new(
                    "DeviceActivity",
                    SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<SerializedWhere>::into)
                                .map(SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::DeviceActivityNone(where_params) => SerializedWhere::new(
                    "DeviceActivity",
                    SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<SerializedWhere>::into)
                                .map(SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        NameEquals(String),
        IdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::NameEquals(value) => Self::NameEquals(value),
                UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
            }
        }
    }
    impl From<Operator<Self>> for WhereParam {
        fn from(op: Operator<Self>) -> Self {
            match op {
                Operator::Not(value) => Self::Not(value),
                Operator::And(value) => Self::And(value),
                Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type UniqueArgs = prisma_client_rust::UniqueArgs<WithParam>;
    pub type ManyArgs = prisma_client_rust::ManyArgs<WhereParam, WithParam, OrderByParam, Cursor>;
    pub type Count<'a> = prisma_client_rust::Count<'a, WhereParam, OrderByParam, Cursor>;
    pub type Create<'a> = prisma_client_rust::Create<'a, SetParam, WithParam, Data>;
    pub type FindUnique<'a> =
        prisma_client_rust::FindUnique<'a, WhereParam, WithParam, SetParam, Data>;
    pub type FindMany<'a> = prisma_client_rust::FindMany<
        'a,
        WhereParam,
        WithParam,
        OrderByParam,
        Cursor,
        SetParam,
        Data,
    >;
    pub type FindFirst<'a> =
        prisma_client_rust::FindFirst<'a, WhereParam, WithParam, OrderByParam, Cursor, Data>;
    pub type Update<'a> = prisma_client_rust::Update<'a, WhereParam, WithParam, SetParam, Data>;
    pub type UpdateMany<'a> = prisma_client_rust::UpdateMany<'a, WhereParam, SetParam>;
    pub type Upsert<'a> = prisma_client_rust::Upsert<'a, WhereParam, SetParam, WithParam, Data>;
    pub type Delete<'a> = prisma_client_rust::Delete<'a, WhereParam, WithParam, Data>;
    pub type DeleteMany<'a> = prisma_client_rust::DeleteMany<'a, WhereParam>;
    pub struct Actions<'a> {
        pub client: &'a PrismaClient,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(
                self.client._new_query_context(),
                QueryInfo::new("Device", _outputs()),
                _where.into(),
            )
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(
                self.client._new_query_context(),
                QueryInfo::new("Device", _outputs()),
                _where,
            )
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(
                self.client._new_query_context(),
                QueryInfo::new("Device", _outputs()),
                _where,
            )
        }
        pub fn create(self, id: String, name: String, mut _params: Vec<SetParam>) -> Create<'a> {
            _params.push(id::set(id));
            _params.push(name::set(name));
            Create::new(
                self.client._new_query_context(),
                QueryInfo::new("Device", _outputs()),
                _params,
            )
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(
                self.client._new_query_context(),
                QueryInfo::new("Device", _outputs()),
                _where.into(),
                _params,
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(
                self.client._new_query_context(),
                QueryInfo::new("Device", _outputs()),
                _where,
                _params,
            )
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(
                self.client._new_query_context(),
                QueryInfo::new("Device", _outputs()),
                _where.into(),
                vec![],
            )
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(
                self.client._new_query_context(),
                QueryInfo::new("Device", _outputs()),
                _where.into(),
            )
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (id, name, mut _params): (String, String, Vec<SetParam>),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.push(id::set(id));
            _params.push(name::set(name));
            Upsert::new(
                self.client._new_query_context(),
                QueryInfo::new("Device", _outputs()),
                _where.into(),
                _params,
                _update,
            )
        }
        pub fn count(self) -> Count<'a> {
            Count::new(
                self.client._new_query_context(),
                QueryInfo::new("Device", _outputs()),
                vec![],
            )
        }
    }
}
pub mod device_activity {
    use super::_prisma::*;
    use super::*;
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn cursor(cursor: String) -> Cursor {
            Cursor::Id(cursor)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::IdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::IdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::IdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::IdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::IdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::IdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::IdEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::IdMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::IdNot(value)
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetId(value.0)
            }
        }
    }
    pub mod updated_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: chrono::DateTime<chrono::FixedOffset>) -> T {
            Set(value).into()
        }
        pub fn equals(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::UpdatedAt(direction)
        }
        pub fn in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::UpdatedAtInVec(value)
        }
        pub fn not_in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::UpdatedAtNotInVec(value)
        }
        pub fn lt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtLt(value)
        }
        pub fn lte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtLte(value)
        }
        pub fn gt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtGt(value)
        }
        pub fn gte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtGte(value)
        }
        pub fn not(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtNot(value)
        }
        pub struct Set(pub chrono::DateTime<chrono::FixedOffset>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetUpdatedAt(value.0)
            }
        }
    }
    pub mod created_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: chrono::DateTime<chrono::FixedOffset>) -> T {
            Set(value).into()
        }
        pub fn equals(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::CreatedAt(direction)
        }
        pub fn in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::CreatedAtInVec(value)
        }
        pub fn not_in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::CreatedAtNotInVec(value)
        }
        pub fn lt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtLt(value)
        }
        pub fn lte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtLte(value)
        }
        pub fn gt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtGt(value)
        }
        pub fn gte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtGte(value)
        }
        pub fn not(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtNot(value)
        }
        pub struct Set(pub chrono::DateTime<chrono::FixedOffset>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetCreatedAt(value.0)
            }
        }
    }
    pub mod activity_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::ActivityIdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::ActivityId(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::ActivityIdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::ActivityIdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::ActivityIdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::ActivityIdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::ActivityIdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::ActivityIdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::ActivityIdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::ActivityIdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::ActivityIdEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::ActivityIdMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::ActivityIdNot(value)
        }
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetActivityId(value.0)
            }
        }
    }
    pub mod device_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::DeviceIdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::DeviceId(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::DeviceIdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::DeviceIdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::DeviceIdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::DeviceIdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::DeviceIdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::DeviceIdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::DeviceIdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::DeviceIdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::DeviceIdEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::DeviceIdMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::DeviceIdNot(value)
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetDeviceId(value.0)
            }
        }
    }
    pub mod activity {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn is(value: Vec<activity::WhereParam>) -> WhereParam {
            WhereParam::ActivityIs(value)
        }
        pub fn is_not(value: Vec<activity::WhereParam>) -> WhereParam {
            WhereParam::ActivityIsNot(value)
        }
        pub struct Fetch(pub activity::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<activity::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::Activity(fetch.0)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(activity::UniqueArgs::new())
        }
        pub fn link<T: From<Link>>(value: activity::UniqueWhereParam) -> T {
            Link(value).into()
        }
        pub fn unlink() -> SetParam {
            SetParam::UnlinkActivity
        }
        pub struct Link(activity::UniqueWhereParam);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkActivity(value.0)
            }
        }
    }
    pub mod device {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn is(value: Vec<device::WhereParam>) -> WhereParam {
            WhereParam::DeviceIs(value)
        }
        pub fn is_not(value: Vec<device::WhereParam>) -> WhereParam {
            WhereParam::DeviceIsNot(value)
        }
        pub struct Fetch(pub device::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<device::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::Device(fetch.0)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(device::UniqueArgs::new())
        }
        pub fn link<T: From<Link>>(value: device::UniqueWhereParam) -> T {
            Link(value).into()
        }
        pub struct Link(device::UniqueWhereParam);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkDevice(value.0)
            }
        }
    }
    pub fn _outputs() -> Vec<Selection> {
        ["ID", "UpdatedAt", "CreatedAt", "ActivityId", "DeviceId"]
            .into_iter()
            .map(|o| {
                let builder = Selection::builder(o);
                builder.build()
            })
            .collect()
    }
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct Data {
        #[serde(rename = "ID")]
        pub id: String,
        #[serde(rename = "UpdatedAt")]
        pub updated_at: chrono::DateTime<chrono::FixedOffset>,
        #[serde(rename = "CreatedAt")]
        pub created_at: chrono::DateTime<chrono::FixedOffset>,
        #[serde(rename = "ActivityId")]
        pub activity_id: Option<String>,
        #[serde(rename = "DeviceId")]
        pub device_id: String,
        #[serde(
            rename = "Activity",
            default,
            skip_serializing_if = "Option::is_none",
            with = "prisma_client_rust::serde::double_option"
        )]
        pub activity: Option<Option<Box<super::activity::Data>>>,
        #[serde(rename = "Device")]
        pub device: Option<Box<super::device::Data>>,
    }
    impl Data {
        pub fn activity(&self) -> Result<Option<&super::activity::Data>, &'static str> {
            self.activity
                .as_ref()
                .ok_or(
                    "Attempted to access 'activity' but did not fetch it using the .with() syntax",
                )
                .map(|v| v.as_ref().map(|v| v.as_ref()))
        }
        pub fn device(&self) -> Result<&super::device::Data, &'static str> {
            self.device
                .as_ref()
                .ok_or("Attempted to access 'device' but did not fetch it using the .with() syntax")
                .map(|v| v.as_ref())
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Activity(super::activity::UniqueArgs),
        Device(super::device::UniqueArgs),
    }
    impl Into<Selection> for WithParam {
        fn into(self) -> Selection {
            match self {
                Self::Activity(args) => {
                    let mut selections = super::activity::_outputs();
                    selections.extend(args.with_params.into_iter().map(Into::<Selection>::into));
                    let mut builder = Selection::builder("Activity");
                    builder.nested_selections(selections);
                    builder.build()
                }
                Self::Device(args) => {
                    let mut selections = super::device::_outputs();
                    selections.extend(args.with_params.into_iter().map(Into::<Selection>::into));
                    let mut builder = Selection::builder("Device");
                    builder.nested_selections(selections);
                    builder.build()
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(String),
        SetUpdatedAt(chrono::DateTime<chrono::FixedOffset>),
        SetCreatedAt(chrono::DateTime<chrono::FixedOffset>),
        SetActivityId(Option<String>),
        SetDeviceId(String),
        LinkActivity(super::activity::UniqueWhereParam),
        UnlinkActivity,
        LinkDevice(super::device::UniqueWhereParam),
    }
    impl Into<(String, PrismaValue)> for SetParam {
        fn into(self) -> (String, PrismaValue) {
            match self {
                SetParam::SetId(value) => ("ID".to_string(), PrismaValue::String(value)),
                SetParam::SetUpdatedAt(value) => {
                    ("UpdatedAt".to_string(), PrismaValue::DateTime(value))
                }
                SetParam::SetCreatedAt(value) => {
                    ("CreatedAt".to_string(), PrismaValue::DateTime(value))
                }
                SetParam::SetActivityId(value) => (
                    "ActivityId".to_string(),
                    value
                        .map(|value| PrismaValue::String(value))
                        .unwrap_or(PrismaValue::Null),
                ),
                SetParam::SetDeviceId(value) => {
                    ("DeviceId".to_string(), PrismaValue::String(value))
                }
                SetParam::LinkActivity(where_param) => (
                    "Activity".to_string(),
                    PrismaValue::Object(vec![(
                        "connect".to_string(),
                        PrismaValue::Object(
                            vec![where_param]
                                .into_iter()
                                .map(Into::<super::activity::WhereParam>::into)
                                .map(Into::<SerializedWhere>::into)
                                .map(SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::UnlinkActivity => (
                    "Activity".to_string(),
                    PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        PrismaValue::Boolean(true),
                    )]),
                ),
                SetParam::LinkDevice(where_param) => (
                    "Device".to_string(),
                    PrismaValue::Object(vec![(
                        "connect".to_string(),
                        PrismaValue::Object(
                            vec![where_param]
                                .into_iter()
                                .map(Into::<super::device::WhereParam>::into)
                                .map(Into::<SerializedWhere>::into)
                                .map(SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(Direction),
        UpdatedAt(Direction),
        CreatedAt(Direction),
        ActivityId(Direction),
        DeviceId(Direction),
    }
    impl Into<(String, PrismaValue)> for OrderByParam {
        fn into(self) -> (String, PrismaValue) {
            match self {
                Self::Id(direction) => {
                    ("ID".to_string(), PrismaValue::String(direction.to_string()))
                }
                Self::UpdatedAt(direction) => (
                    "UpdatedAt".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::CreatedAt(direction) => (
                    "CreatedAt".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::ActivityId(direction) => (
                    "ActivityId".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::DeviceId(direction) => (
                    "DeviceId".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum Cursor {
        Id(String),
    }
    impl Into<(String, PrismaValue)> for Cursor {
        fn into(self) -> (String, PrismaValue) {
            match self {
                Self::Id(cursor) => ("ID".to_string(), PrismaValue::String(cursor)),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        IdEquals(String),
        IdInVec(Vec<String>),
        IdNotInVec(Vec<String>),
        IdLt(String),
        IdLte(String),
        IdGt(String),
        IdGte(String),
        IdContains(String),
        IdStartsWith(String),
        IdEndsWith(String),
        IdMode(QueryMode),
        IdNot(String),
        UpdatedAtEquals(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        UpdatedAtNotInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        UpdatedAtLt(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtLte(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtGt(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtGte(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtNot(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtEquals(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        CreatedAtNotInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        CreatedAtLt(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtLte(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtGt(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtGte(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtNot(chrono::DateTime<chrono::FixedOffset>),
        ActivityIdEquals(Option<String>),
        ActivityIdInVec(Vec<String>),
        ActivityIdNotInVec(Vec<String>),
        ActivityIdLt(String),
        ActivityIdLte(String),
        ActivityIdGt(String),
        ActivityIdGte(String),
        ActivityIdContains(String),
        ActivityIdStartsWith(String),
        ActivityIdEndsWith(String),
        ActivityIdMode(QueryMode),
        ActivityIdNot(String),
        DeviceIdEquals(String),
        DeviceIdInVec(Vec<String>),
        DeviceIdNotInVec(Vec<String>),
        DeviceIdLt(String),
        DeviceIdLte(String),
        DeviceIdGt(String),
        DeviceIdGte(String),
        DeviceIdContains(String),
        DeviceIdStartsWith(String),
        DeviceIdEndsWith(String),
        DeviceIdMode(QueryMode),
        DeviceIdNot(String),
        ActivityIs(Vec<super::activity::WhereParam>),
        ActivityIsNot(Vec<super::activity::WhereParam>),
        DeviceIs(Vec<super::device::WhereParam>),
        DeviceIsNot(Vec<super::device::WhereParam>),
    }
    impl Into<SerializedWhere> for WhereParam {
        fn into(self) -> SerializedWhere {
            match self {
                Self::Not(value) => SerializedWhere::new(
                    "NOT",
                    SerializedWhereValue::Object(
                        value
                            .into_iter()
                            .map(Into::<SerializedWhere>::into)
                            .map(Into::into)
                            .collect(),
                    ),
                ),
                Self::Or(value) => SerializedWhere::new(
                    "OR",
                    SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(Into::<SerializedWhere>::into)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => SerializedWhere::new(
                    "AND",
                    SerializedWhereValue::Object(
                        value
                            .into_iter()
                            .map(Into::<SerializedWhere>::into)
                            .map(Into::into)
                            .collect(),
                    ),
                ),
                Self::IdEquals(value) => SerializedWhere::new(
                    "ID",
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdInVec(value) => SerializedWhere::new(
                    "ID",
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::IdNotInVec(value) => SerializedWhere::new(
                    "ID",
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::IdLt(value) => SerializedWhere::new(
                    "ID",
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdLte(value) => SerializedWhere::new(
                    "ID",
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdGt(value) => SerializedWhere::new(
                    "ID",
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdGte(value) => SerializedWhere::new(
                    "ID",
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdContains(value) => SerializedWhere::new(
                    "ID",
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdStartsWith(value) => SerializedWhere::new(
                    "ID",
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdEndsWith(value) => SerializedWhere::new(
                    "ID",
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdMode(value) => SerializedWhere::new(
                    "ID",
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::IdNot(value) => SerializedWhere::new(
                    "ID",
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UpdatedAtEquals(value) => SerializedWhere::new(
                    "UpdatedAt",
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtInVec(value) => SerializedWhere::new(
                    "UpdatedAt",
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::UpdatedAtNotInVec(value) => SerializedWhere::new(
                    "UpdatedAt",
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::UpdatedAtLt(value) => SerializedWhere::new(
                    "UpdatedAt",
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtLte(value) => SerializedWhere::new(
                    "UpdatedAt",
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtGt(value) => SerializedWhere::new(
                    "UpdatedAt",
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtGte(value) => SerializedWhere::new(
                    "UpdatedAt",
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtNot(value) => SerializedWhere::new(
                    "UpdatedAt",
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtEquals(value) => SerializedWhere::new(
                    "CreatedAt",
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtInVec(value) => SerializedWhere::new(
                    "CreatedAt",
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::CreatedAtNotInVec(value) => SerializedWhere::new(
                    "CreatedAt",
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::CreatedAtLt(value) => SerializedWhere::new(
                    "CreatedAt",
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtLte(value) => SerializedWhere::new(
                    "CreatedAt",
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtGt(value) => SerializedWhere::new(
                    "CreatedAt",
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtGte(value) => SerializedWhere::new(
                    "CreatedAt",
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtNot(value) => SerializedWhere::new(
                    "CreatedAt",
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::ActivityIdEquals(value) => SerializedWhere::new(
                    "ActivityId",
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| PrismaValue::String(value))
                            .unwrap_or(PrismaValue::Null),
                    )]),
                ),
                Self::ActivityIdInVec(value) => SerializedWhere::new(
                    "ActivityId",
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::ActivityIdNotInVec(value) => SerializedWhere::new(
                    "ActivityId",
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::ActivityIdLt(value) => SerializedWhere::new(
                    "ActivityId",
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ActivityIdLte(value) => SerializedWhere::new(
                    "ActivityId",
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ActivityIdGt(value) => SerializedWhere::new(
                    "ActivityId",
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ActivityIdGte(value) => SerializedWhere::new(
                    "ActivityId",
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ActivityIdContains(value) => SerializedWhere::new(
                    "ActivityId",
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ActivityIdStartsWith(value) => SerializedWhere::new(
                    "ActivityId",
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ActivityIdEndsWith(value) => SerializedWhere::new(
                    "ActivityId",
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ActivityIdMode(value) => SerializedWhere::new(
                    "ActivityId",
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::ActivityIdNot(value) => SerializedWhere::new(
                    "ActivityId",
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::DeviceIdEquals(value) => SerializedWhere::new(
                    "DeviceId",
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::DeviceIdInVec(value) => SerializedWhere::new(
                    "DeviceId",
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::DeviceIdNotInVec(value) => SerializedWhere::new(
                    "DeviceId",
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::DeviceIdLt(value) => SerializedWhere::new(
                    "DeviceId",
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::DeviceIdLte(value) => SerializedWhere::new(
                    "DeviceId",
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::DeviceIdGt(value) => SerializedWhere::new(
                    "DeviceId",
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::DeviceIdGte(value) => SerializedWhere::new(
                    "DeviceId",
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::DeviceIdContains(value) => SerializedWhere::new(
                    "DeviceId",
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::DeviceIdStartsWith(value) => SerializedWhere::new(
                    "DeviceId",
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::DeviceIdEndsWith(value) => SerializedWhere::new(
                    "DeviceId",
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::DeviceIdMode(value) => SerializedWhere::new(
                    "DeviceId",
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::DeviceIdNot(value) => SerializedWhere::new(
                    "DeviceId",
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ActivityIs(where_params) => SerializedWhere::new(
                    "Activity",
                    SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<SerializedWhere>::into)
                                .map(SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ActivityIsNot(where_params) => SerializedWhere::new(
                    "Activity",
                    SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<SerializedWhere>::into)
                                .map(SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::DeviceIs(where_params) => SerializedWhere::new(
                    "Device",
                    SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<SerializedWhere>::into)
                                .map(SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::DeviceIsNot(where_params) => SerializedWhere::new(
                    "Device",
                    SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<SerializedWhere>::into)
                                .map(SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        IdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
            }
        }
    }
    impl From<Operator<Self>> for WhereParam {
        fn from(op: Operator<Self>) -> Self {
            match op {
                Operator::Not(value) => Self::Not(value),
                Operator::And(value) => Self::And(value),
                Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type UniqueArgs = prisma_client_rust::UniqueArgs<WithParam>;
    pub type ManyArgs = prisma_client_rust::ManyArgs<WhereParam, WithParam, OrderByParam, Cursor>;
    pub type Count<'a> = prisma_client_rust::Count<'a, WhereParam, OrderByParam, Cursor>;
    pub type Create<'a> = prisma_client_rust::Create<'a, SetParam, WithParam, Data>;
    pub type FindUnique<'a> =
        prisma_client_rust::FindUnique<'a, WhereParam, WithParam, SetParam, Data>;
    pub type FindMany<'a> = prisma_client_rust::FindMany<
        'a,
        WhereParam,
        WithParam,
        OrderByParam,
        Cursor,
        SetParam,
        Data,
    >;
    pub type FindFirst<'a> =
        prisma_client_rust::FindFirst<'a, WhereParam, WithParam, OrderByParam, Cursor, Data>;
    pub type Update<'a> = prisma_client_rust::Update<'a, WhereParam, WithParam, SetParam, Data>;
    pub type UpdateMany<'a> = prisma_client_rust::UpdateMany<'a, WhereParam, SetParam>;
    pub type Upsert<'a> = prisma_client_rust::Upsert<'a, WhereParam, SetParam, WithParam, Data>;
    pub type Delete<'a> = prisma_client_rust::Delete<'a, WhereParam, WithParam, Data>;
    pub type DeleteMany<'a> = prisma_client_rust::DeleteMany<'a, WhereParam>;
    pub struct Actions<'a> {
        pub client: &'a PrismaClient,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(
                self.client._new_query_context(),
                QueryInfo::new("DeviceActivity", _outputs()),
                _where.into(),
            )
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(
                self.client._new_query_context(),
                QueryInfo::new("DeviceActivity", _outputs()),
                _where,
            )
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(
                self.client._new_query_context(),
                QueryInfo::new("DeviceActivity", _outputs()),
                _where,
            )
        }
        pub fn create(
            self,
            id: String,
            device: super::device::UniqueWhereParam,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.push(id::set(id));
            _params.push(device::link(device));
            Create::new(
                self.client._new_query_context(),
                QueryInfo::new("DeviceActivity", _outputs()),
                _params,
            )
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(
                self.client._new_query_context(),
                QueryInfo::new("DeviceActivity", _outputs()),
                _where.into(),
                _params,
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(
                self.client._new_query_context(),
                QueryInfo::new("DeviceActivity", _outputs()),
                _where,
                _params,
            )
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(
                self.client._new_query_context(),
                QueryInfo::new("DeviceActivity", _outputs()),
                _where.into(),
                vec![],
            )
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(
                self.client._new_query_context(),
                QueryInfo::new("DeviceActivity", _outputs()),
                _where.into(),
            )
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (id, device, mut _params): (String, super::device::UniqueWhereParam, Vec<SetParam>),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.push(id::set(id));
            _params.push(device::link(device));
            Upsert::new(
                self.client._new_query_context(),
                QueryInfo::new("DeviceActivity", _outputs()),
                _where.into(),
                _params,
                _update,
            )
        }
        pub fn count(self) -> Count<'a> {
            Count::new(
                self.client._new_query_context(),
                QueryInfo::new("DeviceActivity", _outputs()),
                vec![],
            )
        }
    }
}
pub mod user {
    use super::_prisma::*;
    use super::*;
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn cursor(cursor: String) -> Cursor {
            Cursor::Id(cursor)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::IdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::IdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::IdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::IdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::IdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::IdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::IdEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::IdMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::IdNot(value)
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetId(value.0)
            }
        }
    }
    pub mod name {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::NameEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Name(direction)
        }
        pub fn cursor(cursor: String) -> Cursor {
            Cursor::Name(cursor)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::NameInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::NameNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::NameLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::NameLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::NameGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::NameGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::NameContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::NameStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::NameEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::NameMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::NameNot(value)
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetName(value.0)
            }
        }
    }
    pub mod api_key {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::ApiKeyEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::ApiKey(direction)
        }
        pub fn cursor(cursor: String) -> Cursor {
            Cursor::ApiKey(cursor)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::ApiKeyInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::ApiKeyNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::ApiKeyLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::ApiKeyLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::ApiKeyGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::ApiKeyGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::ApiKeyContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::ApiKeyStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::ApiKeyEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::ApiKeyMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::ApiKeyNot(value)
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetApiKey(value.0)
            }
        }
    }
    pub mod activity {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn some(value: Vec<activity::WhereParam>) -> WhereParam {
            WhereParam::ActivitySome(value)
        }
        pub fn every(value: Vec<activity::WhereParam>) -> WhereParam {
            WhereParam::ActivityEvery(value)
        }
        pub fn none(value: Vec<activity::WhereParam>) -> WhereParam {
            WhereParam::ActivityNone(value)
        }
        pub struct Fetch(pub activity::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<activity::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: activity::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: impl Into<activity::Cursor>) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::Activity(fetch.0)
            }
        }
        pub fn fetch(params: Vec<activity::WhereParam>) -> Fetch {
            Fetch(activity::ManyArgs::new(params))
        }
        pub fn link<T: From<Link>>(params: Vec<activity::UniqueWhereParam>) -> T {
            Link(params).into()
        }
        pub fn unlink(params: Vec<activity::UniqueWhereParam>) -> SetParam {
            SetParam::UnlinkActivity(params)
        }
        pub struct Link(pub Vec<activity::UniqueWhereParam>);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkActivity(value.0)
            }
        }
    }
    pub fn _outputs() -> Vec<Selection> {
        ["ID", "Name", "ApiKey"]
            .into_iter()
            .map(|o| {
                let builder = Selection::builder(o);
                builder.build()
            })
            .collect()
    }
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct Data {
        #[serde(rename = "ID")]
        pub id: String,
        #[serde(rename = "Name")]
        pub name: String,
        #[serde(rename = "ApiKey")]
        pub api_key: String,
        #[serde(rename = "Activity")]
        pub activity: Option<Vec<super::activity::Data>>,
    }
    impl Data {
        pub fn activity(&self) -> Result<&Vec<super::activity::Data>, &'static str> {
            self.activity.as_ref().ok_or(
                "Attempted to access 'activity' but did not fetch it using the .with() syntax",
            )
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Activity(super::activity::ManyArgs),
    }
    impl Into<Selection> for WithParam {
        fn into(self) -> Selection {
            match self {
                Self::Activity(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(super::activity::_outputs());
                    let mut builder = Selection::builder("Activity");
                    builder
                        .nested_selections(nested_selections)
                        .set_arguments(arguments);
                    builder.build()
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(String),
        SetName(String),
        SetApiKey(String),
        LinkActivity(Vec<super::activity::UniqueWhereParam>),
        UnlinkActivity(Vec<super::activity::UniqueWhereParam>),
    }
    impl Into<(String, PrismaValue)> for SetParam {
        fn into(self) -> (String, PrismaValue) {
            match self {
                SetParam::SetId(value) => ("ID".to_string(), PrismaValue::String(value)),
                SetParam::SetName(value) => ("Name".to_string(), PrismaValue::String(value)),
                SetParam::SetApiKey(value) => ("ApiKey".to_string(), PrismaValue::String(value)),
                SetParam::LinkActivity(where_params) => (
                    "Activity".to_string(),
                    PrismaValue::Object(vec![(
                        "connect".to_string(),
                        PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<super::activity::WhereParam>::into)
                                .map(Into::<SerializedWhere>::into)
                                .map(SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::UnlinkActivity(where_params) => (
                    "Activity".to_string(),
                    PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<super::activity::WhereParam>::into)
                                .map(Into::<SerializedWhere>::into)
                                .map(SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(Direction),
        Name(Direction),
        ApiKey(Direction),
    }
    impl Into<(String, PrismaValue)> for OrderByParam {
        fn into(self) -> (String, PrismaValue) {
            match self {
                Self::Id(direction) => {
                    ("ID".to_string(), PrismaValue::String(direction.to_string()))
                }
                Self::Name(direction) => (
                    "Name".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::ApiKey(direction) => (
                    "ApiKey".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum Cursor {
        Id(String),
        Name(String),
        ApiKey(String),
    }
    impl Into<(String, PrismaValue)> for Cursor {
        fn into(self) -> (String, PrismaValue) {
            match self {
                Self::Id(cursor) => ("ID".to_string(), PrismaValue::String(cursor)),
                Self::Name(cursor) => ("Name".to_string(), PrismaValue::String(cursor)),
                Self::ApiKey(cursor) => ("ApiKey".to_string(), PrismaValue::String(cursor)),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        IdEquals(String),
        IdInVec(Vec<String>),
        IdNotInVec(Vec<String>),
        IdLt(String),
        IdLte(String),
        IdGt(String),
        IdGte(String),
        IdContains(String),
        IdStartsWith(String),
        IdEndsWith(String),
        IdMode(QueryMode),
        IdNot(String),
        NameEquals(String),
        NameInVec(Vec<String>),
        NameNotInVec(Vec<String>),
        NameLt(String),
        NameLte(String),
        NameGt(String),
        NameGte(String),
        NameContains(String),
        NameStartsWith(String),
        NameEndsWith(String),
        NameMode(QueryMode),
        NameNot(String),
        ApiKeyEquals(String),
        ApiKeyInVec(Vec<String>),
        ApiKeyNotInVec(Vec<String>),
        ApiKeyLt(String),
        ApiKeyLte(String),
        ApiKeyGt(String),
        ApiKeyGte(String),
        ApiKeyContains(String),
        ApiKeyStartsWith(String),
        ApiKeyEndsWith(String),
        ApiKeyMode(QueryMode),
        ApiKeyNot(String),
        ActivitySome(Vec<super::activity::WhereParam>),
        ActivityEvery(Vec<super::activity::WhereParam>),
        ActivityNone(Vec<super::activity::WhereParam>),
    }
    impl Into<SerializedWhere> for WhereParam {
        fn into(self) -> SerializedWhere {
            match self {
                Self::Not(value) => SerializedWhere::new(
                    "NOT",
                    SerializedWhereValue::Object(
                        value
                            .into_iter()
                            .map(Into::<SerializedWhere>::into)
                            .map(Into::into)
                            .collect(),
                    ),
                ),
                Self::Or(value) => SerializedWhere::new(
                    "OR",
                    SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(Into::<SerializedWhere>::into)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => SerializedWhere::new(
                    "AND",
                    SerializedWhereValue::Object(
                        value
                            .into_iter()
                            .map(Into::<SerializedWhere>::into)
                            .map(Into::into)
                            .collect(),
                    ),
                ),
                Self::IdEquals(value) => SerializedWhere::new(
                    "ID",
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdInVec(value) => SerializedWhere::new(
                    "ID",
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::IdNotInVec(value) => SerializedWhere::new(
                    "ID",
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::IdLt(value) => SerializedWhere::new(
                    "ID",
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdLte(value) => SerializedWhere::new(
                    "ID",
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdGt(value) => SerializedWhere::new(
                    "ID",
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdGte(value) => SerializedWhere::new(
                    "ID",
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdContains(value) => SerializedWhere::new(
                    "ID",
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdStartsWith(value) => SerializedWhere::new(
                    "ID",
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdEndsWith(value) => SerializedWhere::new(
                    "ID",
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdMode(value) => SerializedWhere::new(
                    "ID",
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::IdNot(value) => SerializedWhere::new(
                    "ID",
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::NameEquals(value) => SerializedWhere::new(
                    "Name",
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::NameInVec(value) => SerializedWhere::new(
                    "Name",
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::NameNotInVec(value) => SerializedWhere::new(
                    "Name",
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::NameLt(value) => SerializedWhere::new(
                    "Name",
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::NameLte(value) => SerializedWhere::new(
                    "Name",
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::NameGt(value) => SerializedWhere::new(
                    "Name",
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::NameGte(value) => SerializedWhere::new(
                    "Name",
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::NameContains(value) => SerializedWhere::new(
                    "Name",
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::NameStartsWith(value) => SerializedWhere::new(
                    "Name",
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::NameEndsWith(value) => SerializedWhere::new(
                    "Name",
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::NameMode(value) => SerializedWhere::new(
                    "Name",
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::NameNot(value) => SerializedWhere::new(
                    "Name",
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ApiKeyEquals(value) => SerializedWhere::new(
                    "ApiKey",
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ApiKeyInVec(value) => SerializedWhere::new(
                    "ApiKey",
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::ApiKeyNotInVec(value) => SerializedWhere::new(
                    "ApiKey",
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::ApiKeyLt(value) => SerializedWhere::new(
                    "ApiKey",
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ApiKeyLte(value) => SerializedWhere::new(
                    "ApiKey",
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ApiKeyGt(value) => SerializedWhere::new(
                    "ApiKey",
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ApiKeyGte(value) => SerializedWhere::new(
                    "ApiKey",
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ApiKeyContains(value) => SerializedWhere::new(
                    "ApiKey",
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ApiKeyStartsWith(value) => SerializedWhere::new(
                    "ApiKey",
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ApiKeyEndsWith(value) => SerializedWhere::new(
                    "ApiKey",
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ApiKeyMode(value) => SerializedWhere::new(
                    "ApiKey",
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::ApiKeyNot(value) => SerializedWhere::new(
                    "ApiKey",
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ActivitySome(where_params) => SerializedWhere::new(
                    "Activity",
                    SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<SerializedWhere>::into)
                                .map(SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ActivityEvery(where_params) => SerializedWhere::new(
                    "Activity",
                    SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<SerializedWhere>::into)
                                .map(SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ActivityNone(where_params) => SerializedWhere::new(
                    "Activity",
                    SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<SerializedWhere>::into)
                                .map(SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        NameEquals(String),
        ApiKeyEquals(String),
        IdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::NameEquals(value) => Self::NameEquals(value),
                UniqueWhereParam::ApiKeyEquals(value) => Self::ApiKeyEquals(value),
                UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
            }
        }
    }
    impl From<Operator<Self>> for WhereParam {
        fn from(op: Operator<Self>) -> Self {
            match op {
                Operator::Not(value) => Self::Not(value),
                Operator::And(value) => Self::And(value),
                Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type UniqueArgs = prisma_client_rust::UniqueArgs<WithParam>;
    pub type ManyArgs = prisma_client_rust::ManyArgs<WhereParam, WithParam, OrderByParam, Cursor>;
    pub type Count<'a> = prisma_client_rust::Count<'a, WhereParam, OrderByParam, Cursor>;
    pub type Create<'a> = prisma_client_rust::Create<'a, SetParam, WithParam, Data>;
    pub type FindUnique<'a> =
        prisma_client_rust::FindUnique<'a, WhereParam, WithParam, SetParam, Data>;
    pub type FindMany<'a> = prisma_client_rust::FindMany<
        'a,
        WhereParam,
        WithParam,
        OrderByParam,
        Cursor,
        SetParam,
        Data,
    >;
    pub type FindFirst<'a> =
        prisma_client_rust::FindFirst<'a, WhereParam, WithParam, OrderByParam, Cursor, Data>;
    pub type Update<'a> = prisma_client_rust::Update<'a, WhereParam, WithParam, SetParam, Data>;
    pub type UpdateMany<'a> = prisma_client_rust::UpdateMany<'a, WhereParam, SetParam>;
    pub type Upsert<'a> = prisma_client_rust::Upsert<'a, WhereParam, SetParam, WithParam, Data>;
    pub type Delete<'a> = prisma_client_rust::Delete<'a, WhereParam, WithParam, Data>;
    pub type DeleteMany<'a> = prisma_client_rust::DeleteMany<'a, WhereParam>;
    pub struct Actions<'a> {
        pub client: &'a PrismaClient,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(
                self.client._new_query_context(),
                QueryInfo::new("User", _outputs()),
                _where.into(),
            )
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(
                self.client._new_query_context(),
                QueryInfo::new("User", _outputs()),
                _where,
            )
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(
                self.client._new_query_context(),
                QueryInfo::new("User", _outputs()),
                _where,
            )
        }
        pub fn create(
            self,
            id: String,
            name: String,
            api_key: String,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.push(id::set(id));
            _params.push(name::set(name));
            _params.push(api_key::set(api_key));
            Create::new(
                self.client._new_query_context(),
                QueryInfo::new("User", _outputs()),
                _params,
            )
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(
                self.client._new_query_context(),
                QueryInfo::new("User", _outputs()),
                _where.into(),
                _params,
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(
                self.client._new_query_context(),
                QueryInfo::new("User", _outputs()),
                _where,
                _params,
            )
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(
                self.client._new_query_context(),
                QueryInfo::new("User", _outputs()),
                _where.into(),
                vec![],
            )
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(
                self.client._new_query_context(),
                QueryInfo::new("User", _outputs()),
                _where.into(),
            )
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (id, name, api_key, mut _params): (String, String, String, Vec<SetParam>),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.push(id::set(id));
            _params.push(name::set(name));
            _params.push(api_key::set(api_key));
            Upsert::new(
                self.client._new_query_context(),
                QueryInfo::new("User", _outputs()),
                _where.into(),
                _params,
                _update,
            )
        }
        pub fn count(self) -> Count<'a> {
            Count::new(
                self.client._new_query_context(),
                QueryInfo::new("User", _outputs()),
                vec![],
            )
        }
    }
}
pub mod _prisma {
    use super::*;
    use prisma_client_rust::{
        queries::QueryContext,
        query_core::{QueryExecutor, QuerySchema},
        raw, ExecuteRaw, QueryRaw,
    };
    use serde::{Deserialize, Serialize};
    use std::fmt;
    use std::sync::Arc;
    pub struct PrismaClient {
        executor: Box<dyn QueryExecutor + Send + Sync + 'static>,
        query_schema: Arc<QuerySchema>,
    }
    impl fmt::Debug for PrismaClient {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.debug_struct("PrismaClient").finish()
        }
    }
    impl PrismaClient {
        pub(super) fn _new_query_context(&self) -> QueryContext {
            QueryContext::new(&self.executor, self.query_schema.clone())
        }
        pub(super) fn _new(
            executor: Box<dyn QueryExecutor + Send + Sync + 'static>,
            query_schema: Arc<QuerySchema>,
        ) -> Self {
            Self {
                executor,
                query_schema,
            }
        }
        pub async fn _query_raw<T: serde::de::DeserializeOwned>(
            &self,
            query: raw::Raw,
        ) -> QueryResult<Vec<T>> {
            QueryRaw::new(
                QueryContext::new(&self.executor, self.query_schema.clone()),
                query,
                DATABASE_STR,
            )
            .exec()
            .await
        }
        pub async fn _execute_raw(&self, query: raw::Raw) -> QueryResult<i64> {
            ExecuteRaw::new(
                QueryContext::new(&self.executor, self.query_schema.clone()),
                query,
                DATABASE_STR,
            )
            .exec()
            .await
        }
        pub fn activity(&self) -> activity::Actions {
            activity::Actions { client: &self }
        }
        pub fn device(&self) -> device::Actions {
            device::Actions { client: &self }
        }
        pub fn device_activity(&self) -> device_activity::Actions {
            device_activity::Actions { client: &self }
        }
        pub fn user(&self) -> user::Actions {
            user::Actions { client: &self }
        }
    }
    #[derive(Debug, Clone, Copy, Serialize, Deserialize)]
    pub enum ActivityScalarFieldEnum {
        #[serde(rename = "ID")]
        Id,
        #[serde(rename = "UpdatedAt")]
        UpdatedAt,
        #[serde(rename = "CreatedAt")]
        CreatedAt,
        #[serde(rename = "Name")]
        Name,
        #[serde(rename = "UserId")]
        UserId,
    }
    impl ToString for ActivityScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "ID".to_string(),
                Self::UpdatedAt => "UpdatedAt".to_string(),
                Self::CreatedAt => "CreatedAt".to_string(),
                Self::Name => "Name".to_string(),
                Self::UserId => "UserId".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, Serialize, Deserialize)]
    pub enum DeviceScalarFieldEnum {
        #[serde(rename = "ID")]
        Id,
        #[serde(rename = "Name")]
        Name,
    }
    impl ToString for DeviceScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "ID".to_string(),
                Self::Name => "Name".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, Serialize, Deserialize)]
    pub enum DeviceActivityScalarFieldEnum {
        #[serde(rename = "ID")]
        Id,
        #[serde(rename = "UpdatedAt")]
        UpdatedAt,
        #[serde(rename = "CreatedAt")]
        CreatedAt,
        #[serde(rename = "ActivityId")]
        ActivityId,
        #[serde(rename = "DeviceId")]
        DeviceId,
    }
    impl ToString for DeviceActivityScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "ID".to_string(),
                Self::UpdatedAt => "UpdatedAt".to_string(),
                Self::CreatedAt => "CreatedAt".to_string(),
                Self::ActivityId => "ActivityId".to_string(),
                Self::DeviceId => "DeviceId".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, Serialize, Deserialize)]
    pub enum UserScalarFieldEnum {
        #[serde(rename = "ID")]
        Id,
        #[serde(rename = "Name")]
        Name,
        #[serde(rename = "ApiKey")]
        ApiKey,
    }
    impl ToString for UserScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "ID".to_string(),
                Self::Name => "Name".to_string(),
                Self::ApiKey => "ApiKey".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, Serialize, Deserialize)]
    pub enum SortOrder {
        #[serde(rename = "asc")]
        Asc,
        #[serde(rename = "desc")]
        Desc,
    }
    impl ToString for SortOrder {
        fn to_string(&self) -> String {
            match self {
                Self::Asc => "asc".to_string(),
                Self::Desc => "desc".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, Serialize, Deserialize)]
    pub enum QueryMode {
        #[serde(rename = "default")]
        Default,
        #[serde(rename = "insensitive")]
        Insensitive,
    }
    impl ToString for QueryMode {
        fn to_string(&self) -> String {
            match self {
                Self::Default => "default".to_string(),
                Self::Insensitive => "insensitive".to_string(),
            }
        }
    }
}
pub use _prisma::PrismaClient;
